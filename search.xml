<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lean4</title>
    <url>/2024/12/31/Lean4/</url>
    <content><![CDATA[<p>Lean4：被称为交互式定理证明器（interactive theorem-proving system）的计算机系统（也称为证明助手或形式化系统）提供了另一种表达数学论证的方法。<br>mathlib(Lean mathematical library)是一项由社区推动的工作，旨在建立一个以lean proof assistant形式化的统一数学库。<br>a proof assistant：(一个软件，提供规范语言，依照规范语言定义对象和性质，证明定理，系统检查定理的正确性，直至逻辑基础)<br>Formalization:  我们将用一种规范的语言（如编程语言）来书写数学定义、定理和证明，让 Lean 能够理解。 作为回报，Lean 会提供反馈和信息，解释表达式并保证其格式正确，并最终认证我们证明的正确性。</p>
<p>Lean 是一个工具将复杂表达式转换成形式化语言(dependent type theory)</p>
]]></content>
  </entry>
  <entry>
    <title>Mathematics_in_Lean</title>
    <url>/2025/01/02/Mathematics-in-Lean/</url>
    <content><![CDATA[<p>Mathematics in lean ：基于mathlib库，建造复杂表达式的方式：1.自己写，2.提供instruction 指导如何构建<br>Theorem Proving in Lean: 侧重底层逻辑框架和Lean的核心语法</p>
<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><h2 id="2-basic"><a href="#2-basic" class="headerlink" title="2 basic"></a>2 basic</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- le_div_iff₀这个theorem，以及rm[]</span><br><span class="line">-- 使用方面linarith(线性计算)，和ring(交换)</span><br><span class="line">-- 以及证明时可以把用的定理直接提出来，theorem</span><br><span class="line">-- have h:引入假设，calc 分步计算，让过程更加清晰，因为写出了要证明的每一步的结果</span><br><span class="line">-- tatics： apply , repeat</span><br></pre></td></tr></table></figure>
<h2 id="3-1-Impication-and-the-Universal-Quantifier"><a href="#3-1-Impication-and-the-Universal-Quantifier" class="headerlink" title="3.1 Impication and the Universal Quantifier"></a>3.1 Impication and the Universal Quantifier</h2><p>In lean,in a sequence of implications there are implicit parentheses grouped to the right. </p>
<p>it is common in Lean to use curly brackets to make quantified variables implicit when they can be inferred from subsequent hypotheses.So we can just do lemma to the hypothese without mentioning the objects.即用{}括起来的在调用时不需要显示指出。</p>
<h2 id="5-2-Induction-and-Recursion"><a href="#5-2-Induction-and-Recursion" class="headerlink" title="5.2 Induction and Recursion"></a>5.2 Induction and Recursion</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 归纳</span><br><span class="line">-- inductive types (which are types generated infuctively by a given list of constructors)</span><br><span class="line">-- e.g. the natual numbers are declared as follows( in Prelude.lean)</span><br><span class="line">inductive Nat where</span><br><span class="line">  | zero : Nat -- constructor</span><br><span class="line">  | succ (n : Nat): Nat -- constructor</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">@[simp] -- specifys that the defining equation should be added to the database of identities that the simplifier uses by default</span><br></pre></td></tr></table></figure>

<h2 id="6-1-Defining-Structures"><a href="#6-1-Defining-Structures" class="headerlink" title="6.1 Defining Structures"></a>6.1 Defining Structures</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">structure structure_name where</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h3 id="annotation-when-define-a-structure："><a href="#annotation-when-define-a-structure：" class="headerlink" title="annotation when define a structure："></a>annotation when define a structure：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@[ext] -- extensionality,tells Lean to automatically generate theorems that can be used to prove that two instances of a structure are equal when their components are equal.</span><br></pre></td></tr></table></figure>
<h3 id="define-particular-instances-of-structure"><a href="#define-particular-instances-of-structure" class="headerlink" title="define particular instances of structure"></a>define particular instances of structure</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def inst_name : struc_name where</span><br><span class="line">  ...</span><br><span class="line">  -- e.g. x:=1</span><br><span class="line">---------------------------------</span><br><span class="line">def inst_name : struct_name :=</span><br><span class="line">  ...</span><br><span class="line">  --e.g. &lt;value1 , ,...&gt; -- anonymous constructor notation</span><br><span class="line">---------------------------------</span><br><span class="line">def inst_name :=</span><br><span class="line">  struc_name.mk ...valuek valuek+1 ...</span><br><span class="line">  -- struc_name.mk 是constructor，也可以自己命名，需要在define structure 的时候，比where多 了name和::</span><br><span class="line">  -- structure struc_name where constructor_name ::</span><br><span class="line">  --    ...</span><br><span class="line">-- open a namespace</span><br><span class="line">namespace namespace_name</span><br><span class="line">...</span><br><span class="line">end namespace_name</span><br></pre></td></tr></table></figure>
<h3 id="definations-and-theorems"><a href="#definations-and-theorems" class="headerlink" title="definations and theorems"></a>definations and theorems</h3><p>about namespace: when namespace not open, can use anonymous projection notation,which allows us to write <strong>a.add b</strong> instead of <strong>namespace_name.add a b</strong>.</p>
<p><strong>protected</strong> keyword</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- so that the theorem name is Point.add_comm,even when the namespace is open</span><br><span class="line">protected theorem add_comm (a b :Point) :add a b = add b a:=by</span><br><span class="line">  sorry</span><br></pre></td></tr></table></figure>
<h1 id="Lean-theorem"><a href="#Lean-theorem" class="headerlink" title="Lean theorem"></a>Lean theorem</h1><p>multiple arrows：隐式右结合（associate to the right）</p>
<h1 id="Lean使用快捷键"><a href="#Lean使用快捷键" class="headerlink" title="Lean使用快捷键"></a>Lean使用快捷键</h1><p>Ctrl-Shift-P ： get access to the Lean 4:show all abbreviations<br>Ctrl-Space : completion in the editior to guess the theorem name</p>
<h1 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h1><h2 id="运算的特殊写法"><a href="#运算的特殊写法" class="headerlink" title="运算的特殊写法"></a>运算的特殊写法</h2><ol>
<li>divisibility relation整除关系 |</li>
</ol>
<h2 id="提示写法"><a href="#提示写法" class="headerlink" title="提示写法"></a>提示写法</h2><p>“apply?”可以在右边得到suggestions</p>
<h2 id="重复证明过程的写法"><a href="#重复证明过程的写法" class="headerlink" title="重复证明过程的写法"></a>重复证明过程的写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--1. 使用hypothesis ：任意</span><br><span class="line">--2. 使用repeat</span><br><span class="line">example : min a b = min b a := by</span><br><span class="line">  have h : ∀ x y : ℝ, min x y ≤ min y x := by</span><br><span class="line">    intro x y</span><br><span class="line">    apply le_min</span><br><span class="line">    apply min_le_right</span><br><span class="line">    apply min_le_left</span><br><span class="line">  apply le_antisymm</span><br><span class="line">  apply h</span><br><span class="line">  apply h</span><br><span class="line">-----------------------</span><br><span class="line">example : min a b = min b a := by</span><br><span class="line">  apply le_antisymm</span><br><span class="line">  repeat</span><br><span class="line">    apply le_min</span><br><span class="line">    apply min_le_right</span><br><span class="line">    apply min_le_left</span><br></pre></td></tr></table></figure>
<h2 id="name-of-theorem"><a href="#name-of-theorem" class="headerlink" title="name_of_theorem"></a>name_of_theorem</h2><p>A_of_B_of_C: established something of the form A from hypothese of the form B and C,where A,B,C approximate the way we might read the goals out loud,e.g. x+y&lt;… probably start with add_lt.</p>
<h2 id="example-use-by-not-use-by"><a href="#example-use-by-not-use-by" class="headerlink" title="example use by &amp; not use by"></a>example use by &amp; not use by</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example (a b : R) : a - b = a + -b :=by</span><br><span class="line">  rw[sub_eq_add_neg a b]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">example (a b : R) : a - b = a + -b :=</span><br><span class="line">  sub_eq_add_neg a b</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="语法记录"><a href="#语法记录" class="headerlink" title="语法记录"></a>语法记录</h1><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line">section ... end</span><br><span class="line">-- 变量声明</span><br><span class="line">variable(v1 v2 v3 ... : type) </span><br><span class="line">-- 检查类型，或描述用法</span><br><span class="line">#check ...</span><br><span class="line">#check a -- a:R</span><br><span class="line">#check mul_comm -- mul_comm.&#123;u_1&#125; &#123;G : Type u_1&#125; [CommMagma G] (a b : G) : a * b = b * a</span><br><span class="line"></span><br><span class="line">#check norm_num -- 常量计算与比较，Normalize numerical expressions. Supports the operations + - * / ⁻¹ ^ and % over numerical types such as ℕ, ℤ, ℚ, ℝ, ℂ and some general algebraic types, and can prove goals of the form A = B, A ≠ B, A &lt; B and A ≤ B, where A and B are numerical expressions. It also has a relatively simple primality prover.</span><br><span class="line"></span><br><span class="line">-- Nat.gcd m n :最大公约数,在显示的时候会显示出来m.gcd.n</span><br></pre></td></tr></table></figure>

<h3 id="rfl-is-short-for-“reflexivity”"><a href="#rfl-is-short-for-“reflexivity”" class="headerlink" title="rfl is short for “reflexivity”."></a>rfl is short for “reflexivity”.</h3><h3 id="calc先定义阶段目标再填写过程"><a href="#calc先定义阶段目标再填写过程" class="headerlink" title="calc先定义阶段目标再填写过程"></a>calc先定义阶段目标再填写过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example:(a+b)*(a+b) = a*a+2*a*b +b*b:</span><br><span class="line">    calc</span><br><span class="line">        xx :by</span><br><span class="line">            xx</span><br><span class="line">        _=xxx:=by</span><br><span class="line">            xx</span><br><span class="line">        _=xxxx:=by</span><br><span class="line">            xxxx</span><br></pre></td></tr></table></figure>
<h3 id="have-先提出假设h进行证明，之后可以使用h推断goal"><a href="#have-先提出假设h进行证明，之后可以使用h推断goal" class="headerlink" title="have 先提出假设h进行证明，之后可以使用h推断goal"></a>have 先提出假设h进行证明，之后可以使用h推断goal</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theorem zero_mul(a: R):0*a  =0 := by</span><br><span class="line">    have h: 0*a+0*a = 0*a+0 :=by</span><br><span class="line">        rw[←add_mul,add_zero,add_zero]</span><br><span class="line">    rw[add_left_cancel h]</span><br></pre></td></tr></table></figure>
<h3 id="rw-…-…-…-替换"><a href="#rw-…-…-…-替换" class="headerlink" title="rw[…,…,…]替换"></a>rw[…,…,…]替换</h3><ol>
<li>变量</li>
</ol>
<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>左箭头表示a&#x3D;b:用a替换b</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nth_rw &lt;第几个&gt;[]替换</span><br><span class="line">rw[mul_assoc]--a*b*c = a*(b*c)</span><br><span class="line">rw[mul_assoc]--a*(b*c)=a*b*c</span><br><span class="line">sub_self -- a-a=0</span><br></pre></td></tr></table></figure>
<p>&lt;⬅&gt;mul_assoc <v><br>mul_comm &lt;v1,v2&gt;</p>
<h3 id="tactic：ring"><a href="#tactic：ring" class="headerlink" title="tactic：ring"></a>tactic：ring</h3><p>automation for that follow purely from the ring axioms</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example: c*b*a = b*(a*c):= by</span><br><span class="line">    ring</span><br></pre></td></tr></table></figure>
<p>a ring consists of a collection of<br>objects,<br>R,(R with + is an <strong>abelian group</strong>,with 0 as the additive identity , with negation as inverse)<br>operations + *,and (multiplication is associative with identity 1,and multiplication distributes over addition)<br>constants 0 and 1,and<br>an operation x-&gt;-x </p>
<p>Lean is good not only for proving things about concrete mathematical structures like the natural numbers and the integers, but also for proving things about abstract structures, characterized axiomatically, like rings. Moreover, Lean supports generic reasoning about both abstract and concrete structures, and can be trained to recognize appropriate instances.</p>
]]></content>
  </entry>
  <entry>
    <title>BugBlog</title>
    <url>/2024/12/11/BugBlog/</url>
    <content><![CDATA[<h1 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JAVA</span></span><br><span class="line"><span class="comment">// Wrong!!!,这样写改不了树，put不进去</span></span><br><span class="line"><span class="comment">//	public void NonrecursivePut(Key key,Value val)&#123;</span></span><br><span class="line"><span class="comment">//		if(key==null)throw new IllegalArgumentException(&quot;the 1st of Put() is null&quot;);</span></span><br><span class="line"><span class="comment">//		Node x = root;</span></span><br><span class="line"><span class="comment">//		while(x!=null)&#123;</span></span><br><span class="line"><span class="comment">//			int cmp = key.compareTo(x.key);</span></span><br><span class="line"><span class="comment">//			if(cmp&gt;0) x=x.right;</span></span><br><span class="line"><span class="comment">//			else if(cmp&lt;0) x= x.left;</span></span><br><span class="line"><span class="comment">//			else x.val=val;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		x=new Node(key,val);Wrong!!因为只是将临时引用指向了新创建的对象，而实际的x.left或x.right引用依然为null</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution: 记录父节点，通过修改父节点.left和right进行</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题</title>
    <url>/2024/10/05/hello-world/</url>
    <content><![CDATA[<h2 id="指路Next入门教程"><a href="#指路Next入门教程" class="headerlink" title="指路Next入门教程"></a><a href="https://hexo-next.readthedocs.io/zh-cn/latest/next/">指路Next入门教程</a></h2>]]></content>
      <categories>
        <category>Hexo-Next</category>
      </categories>
      <tags>
        <tag>Beautify</tag>
      </tags>
  </entry>
  <entry>
    <title>compiler impletment learn from Jack W. Crenshaw</title>
    <url>/2024/10/26/compiler-impletment-learn-from-Jack-W-Crenshaw/</url>
    <content><![CDATA[<p><a href="https://compilers.iecc.com/crenshaw">学习网站</a></p>
<h1 id="学习过程中的不懂问题"><a href="#学习过程中的不懂问题" class="headerlink" title="学习过程中的不懂问题"></a>学习过程中的不懂问题</h1><blockquote>
<p>使用栈计算表达式时，‘)’ had  different precedence levels,depending upon whether or not it was already on the stack,you had to give it one value before you put it on the stack, and another to decide when to take it off.(不明白为啥右括号有不同优先级，咋还能入栈)<br>difference between interpreter and compiler : the recognizing of procedure, in the interpreter the recognizing procedure end up being coded as FUNCTIONS that return numeric values to their callers.None of the parsing routines for our compiler did that（不明白解释器和编译器在procedure翻译上的不同）<br>assembler: 目的是生成object code,normally does that on a one-to-one basis(one object instruction per line of source code),but almost ebery assember also permits expression as arguments.In this case, the expression are always constant expressions, and so the assembler isn’t supposed to issue object code for them. Rather, it “interpreters” the expression and computes the corresponding constant result,which is what it actually emits as object code（此处说的汇编器对常量表达式的处理是“lazy”概念，exap: x &#x3D; x+3-2-1最后生成时是对 x&#x3D; x+0甚至是x&#x3D;x）</p>
</blockquote>
<h1 id="阶段1-Single-Num-expression"><a href="#阶段1-Single-Num-expression" class="headerlink" title="阶段1 Single Num expression"></a>阶段1 Single Num expression</h1><h2 id="只含”-“的二元表达式"><a href="#只含”-“的二元表达式" class="headerlink" title="只含”+-“的二元表达式"></a>只含”+-“的二元表达式</h2><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    expr::= term&lt;+-term&gt;</span></span><br><span class="line"><span class="comment">    term::=GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Expression</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term;<span class="comment">&#123;MOVE #GetNum,D0;&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;MOVE D0,D1&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: Add;<span class="comment">&#123;Match(&#x27;+&#x27;);Term;ADD D1,D0;结果存在D0&#125;</span></span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: Substract;<span class="comment">&#123;Match(&#x27;-&#x27;);Term;SUB D1,D0;NEG D0;结果存在D0&#125;</span></span><br><span class="line">    <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="多个操作数"><a href="#多个操作数" class="headerlink" title="多个操作数"></a>多个操作数</h2><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;循环解决,将数压栈解决寄存器有限&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Expression</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term;<span class="comment">&#123;MOVE #GetNum,D0;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>);<span class="comment">&#123;D1=D0;&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: Add;<span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract;<span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB -(SP),D0; NEG D0 ;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="增加”-“"><a href="#增加”-“" class="headerlink" title="增加”*&#x2F;“"></a>增加”*&#x2F;“</h2><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    优先级高，单位更小</span></span><br><span class="line"><span class="comment">    expr::= term &lt;+- term&gt;</span></span><br><span class="line"><span class="comment">    term::= factor &lt;*/ factor&gt;</span></span><br><span class="line"><span class="comment">    factor::= GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Expression</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;压栈&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="keyword">Add</span><span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB (SP)-,D0; NEG D0;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Term</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Factor<span class="punctuation">;</span><span class="comment">&#123;GetNum;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: Multiply<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;*&#x27;);Factor;MUL (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: Divide<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;乘除操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<h2 id="增加”-”"><a href="#增加”-”" class="headerlink" title="增加”()”"></a>增加”()”</h2><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">    factor ::= (expr) or GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Factor</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look =<span class="string">&#x27;(&#x27;</span> than <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE&#x27;</span>+#GetNum+<span class="string">&#x27;,D0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="增加”-作为正负号的数”"><a href="#增加”-作为正负号的数”" class="headerlink" title="增加”-+作为正负号的数”"></a>增加”-+作为正负号的数”</h2><p>增加0-</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    expr::=- or term&lt;+-term&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Expression</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;CLR D0&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;D0=0;&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        term<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;压栈&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="keyword">Add</span><span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB (SP)-,D0; NEG D0;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>


<h1 id="阶段2-Assignment（name-expression，多位数和标识符Token识别）"><a href="#阶段2-Assignment（name-expression，多位数和标识符Token识别）" class="headerlink" title="阶段2 Assignment（name &#x3D; expression，多位数和标识符Token识别）"></a>阶段2 Assignment（name &#x3D; expression，多位数和标识符Token识别）</h1><h2 id="增加-单个字母的标识符（以及无参的函数调用C语言格式）"><a href="#增加-单个字母的标识符（以及无参的函数调用C语言格式）" class="headerlink" title="增加 单个字母的标识符（以及无参的函数调用C语言格式）"></a>增加 单个字母的标识符（以及无参的函数调用C语言格式）</h2><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    factor ::= GetNum | (expre) | Ident</span></span><br><span class="line"><span class="comment">    Ident ::= GetName &lt;&#x27;(&#x27;&#x27;)&#x27;&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Factor</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look =<span class="string">&#x27;(&#x27;</span> than <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> IsAlpha(Look) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        Ident;<span class="comment">&#123;标识符识别&#125;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       EmitLn(<span class="string">&#x27;MOVE&#x27;</span>+#GetNum+<span class="string">&#x27;,D0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;----------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Ident</span>;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">Name</span>:Char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">Name</span> :=GetName;</span><br><span class="line">    <span class="keyword">if</span> Look = <span class="string">&#x27;(&#x27;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        EmitLn(<span class="string">&#x27;BSR &#x27;</span>+<span class="keyword">Name</span>);<span class="comment">&#123;调用函数&#125;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> EmitLn(<span class="string">&#x27;MOVE &#x27;</span>+<span class="keyword">Name</span>+<span class="string">&#x27;(PC),D0&#x27;</span>);<span class="comment">&#123;将操作数取出来放在D0&#125;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="增加赋值语句"><a href="#增加赋值语句" class="headerlink" title="增加赋值语句"></a>增加赋值语句</h2><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Assignment ::= GetName = expr</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Assignment</span>;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">Name</span>:char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">Name</span>:=GetName;</span><br><span class="line">    Match(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    Expression;</span><br><span class="line">    <span class="comment">&#123;赋值汇编&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;LEA &#x27;</span>+<span class="keyword">Name</span>+<span class="string">&#x27;(PC)&#x27;</span>,A0);<span class="comment">&#123;A0是地址寄存器，存放Name的地址，PC相对寻址&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;MOVE D0,(A0)&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="增加多位数和多个字母"><a href="#增加多位数和多个字母" class="headerlink" title="增加多位数和多个字母"></a>增加多位数和多个字母</h2><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    GetNum，GetName重写<span class="keyword">while</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> GetNum:<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">var</span> Value:<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Value:=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isDigit(Look) <span class="keyword">then</span> Expected(<span class="string">&#x27;Digit&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> isDigit(Look) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        Value:=Value+Look;</span><br><span class="line">        GetChar;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="增加空格过滤"><a href="#增加空格过滤" class="headerlink" title="增加空格过滤"></a>增加空格过滤</h2><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    识别空格，过滤空格，保证其余的识别开头第一个是非空格字符，即：</span><br><span class="line"></span><br><span class="line">    Init 中GetChar后要SkipWhite；</span><br><span class="line"></span><br><span class="line">    GetNum/Name 最后要SkipWhite;</span><br><span class="line">    </span><br><span class="line">    tips: LR (<span class="name">#10</span>,<span class="comment">^J</span>) CR($<span class="number">13</span>,<span class="comment">^M</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="阶段3：简单的interpreter"><a href="#阶段3：简单的interpreter" class="headerlink" title="阶段3：简单的interpreter"></a>阶段3：简单的interpreter</h1><p>interpreter就是等到必要时才打印，否则就一直计算</p>
<h2 id="识别表达式"><a href="#识别表达式" class="headerlink" title="识别表达式"></a>识别表达式</h2><figure class="highlight d"><table><tr><td class="code"><pre><span class="line">expr := -<span class="comment">/+ term &lt;+/</span>- term&gt;</span><br><span class="line">term := factor &lt;*/ factor&gt;</span><br><span class="line">factor := GetNum | (expr) </span><br></pre></td></tr></table></figure>
<h3 id="一位数字-即时计算"><a href="#一位数字-即时计算" class="headerlink" title="一位数字(即时计算)"></a>一位数字(即时计算)</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">-------------------------&#125;</span></span><br><span class="line">&#123;GetNum&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">GetNum:integer;</span></span><br><span class="line">begin</span><br><span class="line">    if not <span class="keyword">is</span>Digit(Look) <span class="keyword">then</span> Expected(<span class="symbol">&#x27;Integer</span>&#x27;);</span><br><span class="line">    GetNum := Ord(Look)-Ord(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    GetChar;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">----------------------------&#125;</span></span><br><span class="line">&#123;Factor&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Factor:integer;</span></span><br><span class="line">begin</span><br><span class="line">    if Look = &#x27;(&#x27; then</span><br><span class="line">    begin</span><br><span class="line">        Match(&#x27;(&#x27;);</span><br><span class="line">        Factor := Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> Factor := GetNum;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">-------------------------------&#125;</span></span><br><span class="line">&#123; Term &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Term:integer;</span></span><br><span class="line">var</span><br><span class="line">    Value :integer;</span><br><span class="line">begin</span><br><span class="line">    Value := Factor;</span><br><span class="line">    while <span class="keyword">is</span>Mulop(Look) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            Value:=Value * Factor;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            Value:=Value div Factor;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    Term := Value;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">-----------------------------&#125;</span></span><br><span class="line">&#123;Expression&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Expression:integer;</span></span><br><span class="line">var</span><br><span class="line">    Value:integer;</span><br><span class="line">begin</span><br><span class="line">    if <span class="keyword">is</span>Addop(Look) <span class="keyword">then</span> <span class="keyword">begin</span>&#123;能省略吗？不能因为省略后无法识别Term开头的表达式&#125;</span><br><span class="line">        Value:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> Value:= Term;</span><br><span class="line">    <span class="keyword">while</span> isAddop(Look) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            Value := Value +Term;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            Value := Value -Term;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    Expression := Value;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="多位数字-改动GetNum"><a href="#多位数字-改动GetNum" class="headerlink" title="多位数字(改动GetNum)"></a>多位数字(改动GetNum)</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">procadure GetChar;</span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">    <span class="title">Read</span><span class="params">(Look)</span></span>;</span><br><span class="line">end;</span><br><span class="line">function GetNum:integer;</span><br><span class="line">var</span><br><span class="line">    Value: integer;</span><br><span class="line">begin</span><br><span class="line">    Value :=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="keyword">not</span> <span class="title">isDigit</span><span class="params">(Look)</span> then <span class="title">Expected</span><span class="params">(<span class="string">&quot;Integer&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">isDigit</span><span class="params">(Look)</span> <span class="keyword">do</span></span></span><br><span class="line"><span class="function">    begin</span></span><br><span class="line"><span class="function">        Value :=</span> Value * <span class="number">10</span> +<span class="built_in">Ord</span>(Look)-<span class="built_in">Ord</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        GetChar;</span><br><span class="line">    end;</span><br><span class="line">    GetNum := Value;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h3 id="NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出"><a href="#NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出" class="headerlink" title="NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出"></a>NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出</h3><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    在我的电脑上windows的WSL上NewLine只用了LF</span></span><br><span class="line"><span class="comment">    结束符.</span></span><br><span class="line"><span class="comment">    输入符号表命令 ？Name Value</span></span><br><span class="line"><span class="comment">    输出符号表命令 ！Name </span></span><br><span class="line"><span class="comment">    对于WhiteSpace（在一个单元结束下一个单元开始前跳过中间的空格）：最小读取单元是数字或者单个字符，故在init的GetChar后添加skipWhite，在GetNum和GetName结束添加skipWhite（读到第一个非空格字符）,还需要在match后加上skipWhite</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123; 符号表 &#125;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">Table[<span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>] <span class="keyword">of</span> integer;</span><br><span class="line"><span class="comment">&#123; Input Table&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Input</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Match(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    <span class="keyword">Read</span>(Table[GetName]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">&#123;Output&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Output</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Match(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="keyword">Write</span>(Table[GetName]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">NewLine</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> isNewLine(Look) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            GetChar;</span><br><span class="line">            SkipWhite;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">&#123; Main &#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span> </span><br><span class="line">        <span class="string">&#x27;?&#x27;</span>: Input;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span>: Output;</span><br><span class="line">        <span class="keyword">else</span> Assignment;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        NewLine;</span><br><span class="line">        <span class="keyword">until</span> Look = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>turbo pascal</tag>
        <tag>68000 Assembly</tag>
        <tag>Jack W. Crenshaw</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
</search>
