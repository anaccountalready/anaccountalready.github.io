<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lean4</title>
    <url>/2024/12/31/Lean4/</url>
    <content><![CDATA[<p>Lean4：被称为交互式定理证明器（interactive theorem-proving system）的计算机系统（也称为证明助手或形式化系统）提供了另一种表达数学论证的方法。<br>mathlib(Lean mathematical library)是一项由社区推动的工作，旨在建立一个以lean proof assistant形式化的统一数学库。<br>a proof assistant：(一个软件，提供规范语言，依照规范语言定义对象和性质，证明定理，系统检查定理的正确性，直至逻辑基础)<br>Formalization:  我们将用一种规范的语言（如编程语言）来书写数学定义、定理和证明，让 Lean 能够理解。 作为回报，Lean 会提供反馈和信息，解释表达式并保证其格式正确，并最终认证我们证明的正确性。</p>
<p>Lean 是一个工具将复杂表达式转换成形式化语言(dependent type theory)</p>
<h1 id="Syntax-Model"><a href="#Syntax-Model" class="headerlink" title="Syntax Model"></a>Syntax Model</h1><p><a href="https://lean-lang.org/doc/reference/latest/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Syntax-Model">sytax model</a><br>Lean’s parser produces a concrete syntax tree,of type <code>Lean.Syntax</code>(is an inductive type that represents all of Lean’s syntax,including commands,terms,tactics , and any custom extensions)all of those are basic building blocks: Atoms(fundamental terminals),Identifiers,Nodes(the parsing of nonterminals,contain a syntax kind), Missing Syntax(error mess)<br>Constructors of <code>Lean.Syntax</code>:missing,node,atom,ident</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">Copyright (c) 2023 Eric Wieser. All rights reserved.</span><br><span class="line">Released under Apache 2.0 license as described in the file LICENSE.</span><br><span class="line">Authors: Eric Wieser</span><br><span class="line">-/</span><br><span class="line">syntax (name := eqns) &quot;eqns&quot; ident* : attr</span><br><span class="line"></span><br><span class="line">initialize eqnsAttribute : NameMapExtension (Array Name) ←</span><br><span class="line">  registerNameMapAttribute &#123;</span><br><span class="line">    name  := `eqns</span><br><span class="line">    descr := &quot;Overrides the equation lemmas for a declation to the provided list&quot;</span><br><span class="line">    add   :=  fun</span><br><span class="line">    | _, `(attr| eqns $[$names]*) =&gt; -- 这里面的第二个参数是模式匹配，捕获了eqns关键字后面的所有标识符</span><br><span class="line">      pure &lt;| names.map (fun n =&gt; n.getId)</span><br><span class="line">    | _, _ =&gt; Lean.Elab.throwUnsupportedSyntax &#125;</span><br><span class="line"></span><br><span class="line">initialize Lean.Meta.registerGetEqnsFn (fun name =&gt; do</span><br><span class="line">  pure (eqnsAttribute.find? (← getEnv) name))</span><br></pre></td></tr></table></figure>
<p>本来是def M : ℕ → Matrix m n ℕ<br>def M : ℕ → Matrix (Fin 3) (Fin 3) ℕ – 类型不匹配的原因之一：没有指定矩阵的具体维数<br>| 0 &#x3D;&gt; Matrix.of (fun i j &#x3D;&gt; if (i &#x3D; j) then 1 else 0)<br>| 1 &#x3D;&gt; Matrix.of (fun i j &#x3D;&gt; if (i &#x3D; j) then 2 else 0)<br>| _ &#x3D;&gt; Matrix.of (fun i j &#x3D;&gt; 3)</p>
]]></content>
  </entry>
  <entry>
    <title>Liner_Algebra</title>
    <url>/2025/01/31/Liner-Algebra/</url>
    <content><![CDATA[<h2 id="多线性映射"><a href="#多线性映射" class="headerlink" title="多线性映射"></a>多线性映射</h2><h2 id="交替多线性映射（ALternation）"><a href="#交替多线性映射（ALternation）" class="headerlink" title="交替多线性映射（ALternation）"></a>交替多线性映射（ALternation）</h2><p>交替映射是一个特殊的多线性映射，具备一种对称性质，如果任意两个输入变量间交换，函数的值会改变符号。这意味着交替映射在某些情况下是反对称的。<br>例子：<br>f(v1,v2…vk)&#x3D; - f(v2,v1…vk)</p>
<p>等价于<br>${\displaystyle f(x_{\sigma (1)},\dots ,x_{\sigma (n)})&#x3D;(\operatorname {sgn} \sigma )f(x_{1},\dots ,x_{n})\quad {\text{ for any }}\sigma \in \mathrm {S} _{n},}$<br>所以行列式是交替映射<br>定义：<br>R: 交换环<br>V，W是R上的modules<br>${\displaystyle f:V^{n}\to W}$</p>
<ol>
<li>只要存在xi&#x3D;xj（i不等于j）然后f(x1, …, xn)&#x3D;0</li>
</ol>
<p>向量空间上：<br>V，W是同一个域上的向量空间<br>如果x1，…xn线性相关，那么f(x1, …, xn)&#x3D;0，这就是多线性映射</p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>空间中的有向箭头，<br>列表<br>计算： 向量相加，向量数乘<br>#<br>向量的线性组合： 向量的数乘之和 a * $\vec{v}$ + b * $\vec{w}$ (a b 是可以任意变化的，代表对向量的伸缩)<br>张成的空间：所有表示为给定定向量线性组合的向量集合e.g. 一个平面就是两个（任意维）线性无关向量张成的空间；三个三维线性无关向量张成的空间三维空间<br>Linearly dependent: 一组向量中至少有一个是多余的，没有对张成的空间做出任何贡献，当有多个向量移除一个向量不会减少张成的空间，就称它们线性相关（其中一个向量可以被其他所有向量的线性组合表示出来）<br>Linearly independent:一组向量都增加了张成的空间 the only solution to $a * \vec{v} + b * \vec{w} + c * \vec{u} &#x3D; \vec{0} $ is a &#x3D; b &#x3D; c &#x3D; 0</p>
<p>The basis of a vector space is a set of linearly independent vectors that span the full space.基就是张成该空间的线性无关向量的集合</p>
<h1 id="linear-transformation（变换后直线依旧是直线，原点固定，看作保持网格线平行并且等距分布）"><a href="#linear-transformation（变换后直线依旧是直线，原点固定，看作保持网格线平行并且等距分布）" class="headerlink" title="linear transformation（变换后直线依旧是直线，原点固定，看作保持网格线平行并且等距分布）"></a>linear transformation（变换后直线依旧是直线，原点固定，看作保持网格线平行并且等距分布）</h1><p>可以把矩阵的列看成变换后的基向量，把矩阵乘积看成线性组合</p>
<p>例子： 一个坐标系，改变坐标距离，就不是线性变换，因为对角线原来是直线，变换后不是直线了</p>
<h1 id="the-“determinant”-of-a-transformation"><a href="#the-“determinant”-of-a-transformation" class="headerlink" title="the “determinant” of a transformation"></a>the “determinant” of a transformation</h1><p>行列式：线性变换对面积产生改变的比例
 </p>
]]></content>
      <categories>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>BugBlog</title>
    <url>/2024/12/11/BugBlog/</url>
    <content><![CDATA[<h1 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JAVA</span></span><br><span class="line"><span class="comment">// Wrong!!!,这样写改不了树，put不进去</span></span><br><span class="line"><span class="comment">//	public void NonrecursivePut(Key key,Value val)&#123;</span></span><br><span class="line"><span class="comment">//		if(key==null)throw new IllegalArgumentException(&quot;the 1st of Put() is null&quot;);</span></span><br><span class="line"><span class="comment">//		Node x = root;</span></span><br><span class="line"><span class="comment">//		while(x!=null)&#123;</span></span><br><span class="line"><span class="comment">//			int cmp = key.compareTo(x.key);</span></span><br><span class="line"><span class="comment">//			if(cmp&gt;0) x=x.right;</span></span><br><span class="line"><span class="comment">//			else if(cmp&lt;0) x= x.left;</span></span><br><span class="line"><span class="comment">//			else x.val=val;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		x=new Node(key,val);Wrong!!因为只是将临时引用指向了新创建的对象，而实际的x.left或x.right引用依然为null</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution: 记录父节点，通过修改父节点.left和right进行</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Mathematics_in_Lean</title>
    <url>/2025/01/02/Mathematics-in-Lean/</url>
    <content><![CDATA[<p>Mathematics in lean ：基于mathlib库，建造复杂表达式的方式：1.自己写，2.提供instruction 指导如何构建<br>Theorem Proving in Lean: 侧重底层逻辑框架和Lean的核心语法</p>
<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><h1 id="Linear-algebra写法"><a href="#Linear-algebra写法" class="headerlink" title="Linear algebra写法"></a>Linear algebra写法</h1><h2 id="2-basic"><a href="#2-basic" class="headerlink" title="2 basic"></a>2 basic</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- le_div_iff₀这个theorem，以及rm[]</span><br><span class="line">-- 使用方面linarith(线性计算)，和ring(交换)</span><br><span class="line">-- 以及证明时可以把用的定理直接提出来，theorem</span><br><span class="line">-- have h:引入假设，calc 分步计算，让过程更加清晰，因为写出了要证明的每一步的结果</span><br><span class="line">-- tatics： apply , repeat</span><br></pre></td></tr></table></figure>
<h2 id="3-1-Impication-and-the-Universal-Quantifier"><a href="#3-1-Impication-and-the-Universal-Quantifier" class="headerlink" title="3.1 Impication and the Universal Quantifier"></a>3.1 Impication and the Universal Quantifier</h2><p>In lean,in a sequence of implications there are implicit parentheses grouped to the right. </p>
<p>it is common in Lean to use curly brackets to make quantified variables implicit when they can be inferred from subsequent hypotheses.So we can just do lemma to the hypothese without mentioning the objects.即用{}括起来的在调用时不需要显示指出。</p>
<h2 id="5-2-Induction-and-Recursion"><a href="#5-2-Induction-and-Recursion" class="headerlink" title="5.2 Induction and Recursion"></a>5.2 Induction and Recursion</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 归纳</span><br><span class="line">-- inductive types (which are types generated infuctively by a given list of constructors)</span><br><span class="line">-- e.g. the natual numbers are declared as follows( in Prelude.lean)</span><br><span class="line">inductive Nat where</span><br><span class="line">  | zero : Nat -- constructor</span><br><span class="line">  | succ (n : Nat): Nat -- constructor</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">@[simp] -- specifys that the defining equation should be added to the database of identities that the simplifier uses by default</span><br></pre></td></tr></table></figure>

<h2 id="6-1-Defining-Structures"><a href="#6-1-Defining-Structures" class="headerlink" title="6.1 Defining Structures"></a>6.1 Defining Structures</h2><p><code>structure</code> can specify not only <strong>data types</strong> but also <strong>constraints  that the data must satisfy(In lean,these are represented as fields of type <code>Prop</code>)</strong>.<br><code>def</code> 可以用来定义structure实例<br><code>subtype</code>类型({x: alpha &#x2F;&#x2F; p x}表示for all a in alpha，p x is true) construction combines a piece of data with a property.</p>
<blockquote>
<p>structure的好处：But even though we can use products, subtypes, and Sigma types instead of structures, using structures has a number of advantages. Defining a structure abstracts away the underlying representation and provides custom names for the functions that access the components. This makes proofs more robust: proofs that rely only on the interface to a structure will generally continue to work when we change the definition, as long as we redefine the old accessors in terms of the new definition. Moreover, as we are about to see, Lean provides support for weaving structures together into a rich, interconnected hierarchy, and for managing the interactions between them.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">structure structure_name where</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h3 id="annotation-when-define-a-structure："><a href="#annotation-when-define-a-structure：" class="headerlink" title="annotation when define a structure："></a>annotation when define a structure：</h3><p><code>structure</code> can bundle together data,so as the <code>and符号</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 此注解表示自动生成定理: 当结构体的两个实例组成部分对应相同时，这两个实例相等</span><br><span class="line">@[ext] -- extensionality,tells Lean to automatically generate theorems that can be used to prove that two instances of a structure are equal when their components are equal.</span><br></pre></td></tr></table></figure>
<h3 id="define-particular-instances-of-structure"><a href="#define-particular-instances-of-structure" class="headerlink" title="define particular instances of structure"></a>define particular instances of structure</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def inst_name : struc_name where</span><br><span class="line">  ...</span><br><span class="line">  -- e.g. x:=1</span><br><span class="line">---------------------------------</span><br><span class="line">def inst_name : struct_name :=</span><br><span class="line">  ...</span><br><span class="line">  --e.g. &lt;value1 , ,...&gt; -- anonymous constructor notation</span><br><span class="line">---------------------------------</span><br><span class="line">def inst_name :=</span><br><span class="line">  struc_name.mk ...valuek valuek+1 ...</span><br><span class="line">  -- struc_name.mk 是constructor，也可以自己命名，需要在define structure 的时候，比where多 了name和::</span><br><span class="line">  -- structure struc_name where constructor_name ::</span><br><span class="line">  --    ...</span><br><span class="line">-- open a namespace</span><br><span class="line">namespace namespace_name</span><br><span class="line">...</span><br><span class="line">end namespace_name</span><br></pre></td></tr></table></figure>
<h3 id="definations-and-theorems"><a href="#definations-and-theorems" class="headerlink" title="definations and theorems"></a>definations and theorems</h3><p>about namespace: when namespace not open, can use anonymous projection notation,which allows us to write <strong>a.add b</strong> instead of <strong>namespace_name.add a b</strong>.</p>
<p><strong>protected</strong> keyword</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- so that the theorem name is Point.add_comm,even when the namespace is open</span><br><span class="line">protected theorem add_comm (a b :Point) :add a b = add b a:=by</span><br><span class="line">  sorry</span><br></pre></td></tr></table></figure>
<h2 id="6-2-Algebraic-Structures"><a href="#6-2-Algebraic-Structures" class="headerlink" title="6.2 Algebraic Structures"></a>6.2 Algebraic Structures</h2><p><strong>abelian or commutative group</strong> : set A, operation •,假设a b ∈ A,则需要满足Closure （a · b ∈ A），Associativity（结合律），Identity element (必存在e∈A就是元 使得a · e &#x3D; e · a &#x3D; a)，Inverse element(对任意a，都有a · b &#x3D; b · a &#x3D; e)，Commutativity（交换律）<br><strong>lattice</strong> ： 带有join和meet（leat upper bound 和greatest lower bound）偏序集合<br><strong>ring</strong> ： 加法abelian group和an associative multiplication operation *，和identity 1，且multiplication distributes over addition.如果乘法是交换的则环是交换的</p>
<h1 id="Lean-theorem"><a href="#Lean-theorem" class="headerlink" title="Lean theorem"></a>Lean theorem</h1><p>multiple arrows：隐式右结合（associate to the right）</p>
<h1 id="Lean使用快捷键"><a href="#Lean使用快捷键" class="headerlink" title="Lean使用快捷键"></a>Lean使用快捷键</h1><p>Ctrl-Shift-P ： get access to the Lean 4:show all abbreviations<br>Ctrl-Space : completion in the editior to guess the theorem name</p>
<h1 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h1><h2 id="运算的特殊写法"><a href="#运算的特殊写法" class="headerlink" title="运算的特殊写法"></a>运算的特殊写法</h2><ol>
<li>divisibility relation整除关系 |</li>
</ol>
<h2 id="提示写法"><a href="#提示写法" class="headerlink" title="提示写法"></a>提示写法</h2><p>“apply?”可以在右边得到suggestions</p>
<h2 id="重复证明过程的写法"><a href="#重复证明过程的写法" class="headerlink" title="重复证明过程的写法"></a>重复证明过程的写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--1. 使用hypothesis ：任意</span><br><span class="line">--2. 使用repeat</span><br><span class="line">example : min a b = min b a := by</span><br><span class="line">  have h : ∀ x y : ℝ, min x y ≤ min y x := by</span><br><span class="line">    intro x y</span><br><span class="line">    apply le_min</span><br><span class="line">    apply min_le_right</span><br><span class="line">    apply min_le_left</span><br><span class="line">  apply le_antisymm</span><br><span class="line">  apply h</span><br><span class="line">  apply h</span><br><span class="line">-----------------------</span><br><span class="line">example : min a b = min b a := by</span><br><span class="line">  apply le_antisymm</span><br><span class="line">  repeat</span><br><span class="line">    apply le_min</span><br><span class="line">    apply min_le_right</span><br><span class="line">    apply min_le_left</span><br></pre></td></tr></table></figure>
<h2 id="name-of-theorem"><a href="#name-of-theorem" class="headerlink" title="name_of_theorem"></a>name_of_theorem</h2><p>A_of_B_of_C: established something of the form A from hypothese of the form B and C,where A,B,C approximate the way we might read the goals out loud,e.g. x+y&lt;… probably start with add_lt.</p>
<h2 id="example-use-by-not-use-by"><a href="#example-use-by-not-use-by" class="headerlink" title="example use by &amp; not use by"></a>example use by &amp; not use by</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example (a b : R) : a - b = a + -b :=by</span><br><span class="line">  rw[sub_eq_add_neg a b]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">example (a b : R) : a - b = a + -b :=</span><br><span class="line">  sub_eq_add_neg a b</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="语法记录"><a href="#语法记录" class="headerlink" title="语法记录"></a>语法记录</h1><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line">section ... end</span><br><span class="line">-- 变量声明</span><br><span class="line">variable(v1 v2 v3 ... : type) </span><br><span class="line">-- 检查类型，或描述用法</span><br><span class="line">#check ...</span><br><span class="line">#check a -- a:R</span><br><span class="line">#check mul_comm -- mul_comm.&#123;u_1&#125; &#123;G : Type u_1&#125; [CommMagma G] (a b : G) : a * b = b * a</span><br><span class="line"></span><br><span class="line">#check norm_num -- 常量计算与比较，Normalize numerical expressions. Supports the operations + - * / ⁻¹ ^ and % over numerical types such as ℕ, ℤ, ℚ, ℝ, ℂ and some general algebraic types, and can prove goals of the form A = B, A ≠ B, A &lt; B and A ≤ B, where A and B are numerical expressions. It also has a relatively simple primality prover.</span><br><span class="line"></span><br><span class="line">-- Nat.gcd m n :最大公约数,在显示的时候会显示出来m.gcd.n</span><br></pre></td></tr></table></figure>

<h3 id="rfl-is-short-for-“reflexivity”"><a href="#rfl-is-short-for-“reflexivity”" class="headerlink" title="rfl is short for “reflexivity”."></a>rfl is short for “reflexivity”.</h3><h3 id="calc先定义阶段目标再填写过程"><a href="#calc先定义阶段目标再填写过程" class="headerlink" title="calc先定义阶段目标再填写过程"></a>calc先定义阶段目标再填写过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example:(a+b)*(a+b) = a*a+2*a*b +b*b:</span><br><span class="line">    calc</span><br><span class="line">        xx :by</span><br><span class="line">            xx</span><br><span class="line">        _=xxx:=by</span><br><span class="line">            xx</span><br><span class="line">        _=xxxx:=by</span><br><span class="line">            xxxx</span><br></pre></td></tr></table></figure>
<h3 id="have-先提出假设h进行证明，之后可以使用h推断goal"><a href="#have-先提出假设h进行证明，之后可以使用h推断goal" class="headerlink" title="have 先提出假设h进行证明，之后可以使用h推断goal"></a>have 先提出假设h进行证明，之后可以使用h推断goal</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theorem zero_mul(a: R):0*a  =0 := by</span><br><span class="line">    have h: 0*a+0*a = 0*a+0 :=by</span><br><span class="line">        rw[←add_mul,add_zero,add_zero]</span><br><span class="line">    rw[add_left_cancel h]</span><br></pre></td></tr></table></figure>
<h3 id="rw-…-…-…-替换"><a href="#rw-…-…-…-替换" class="headerlink" title="rw[…,…,…]替换"></a>rw[…,…,…]替换</h3><ol>
<li>变量</li>
</ol>
<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>左箭头表示a&#x3D;b:用a替换b</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nth_rw &lt;第几个&gt;[]替换</span><br><span class="line">rw[mul_assoc]--a*b*c = a*(b*c)</span><br><span class="line">rw[mul_assoc]--a*(b*c)=a*b*c</span><br><span class="line">sub_self -- a-a=0</span><br></pre></td></tr></table></figure>
<p>&lt;⬅&gt;mul_assoc <v><br>mul_comm &lt;v1,v2&gt;</p>
<h3 id="tactic：ring"><a href="#tactic：ring" class="headerlink" title="tactic：ring"></a>tactic：ring</h3><p>automation for that follow purely from the ring axioms</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example: c*b*a = b*(a*c):= by</span><br><span class="line">    ring</span><br></pre></td></tr></table></figure>
<p>a ring consists of a collection of<br>objects,<br>R,(R with + is an <strong>abelian group</strong>,with 0 as the additive identity , with negation as inverse)<br>operations + *,and (multiplication is associative with identity 1,and multiplication distributes over addition)<br>constants 0 and 1,and<br>an operation x-&gt;-x </p>
<p>Lean is good not only for proving things about concrete mathematical structures like the natural numbers and the integers, but also for proving things about abstract structures, characterized axiomatically, like rings. Moreover, Lean supports generic reasoning about both abstract and concrete structures, and can be trained to recognize appropriate instances.</p>
]]></content>
      <categories>
        <category>Lean</category>
      </categories>
      <tags>
        <tag>Lean</tag>
      </tags>
  </entry>
  <entry>
    <title>compiler impletment learn from Jack W. Crenshaw</title>
    <url>/2024/10/26/compiler-impletment-learn-from-Jack-W-Crenshaw/</url>
    <content><![CDATA[<p><a href="https://compilers.iecc.com/crenshaw">学习网站</a></p>
<h1 id="学习过程中的不懂问题"><a href="#学习过程中的不懂问题" class="headerlink" title="学习过程中的不懂问题"></a>学习过程中的不懂问题</h1><blockquote>
<p>使用栈计算表达式时，‘)’ had  different precedence levels,depending upon whether or not it was already on the stack,you had to give it one value before you put it on the stack, and another to decide when to take it off.(不明白为啥右括号有不同优先级，咋还能入栈)<br>difference between interpreter and compiler : the recognizing of procedure, in the interpreter the recognizing procedure end up being coded as FUNCTIONS that return numeric values to their callers.None of the parsing routines for our compiler did that（不明白解释器和编译器在procedure翻译上的不同）<br>assembler: 目的是生成object code,normally does that on a one-to-one basis(one object instruction per line of source code),but almost ebery assember also permits expression as arguments.In this case, the expression are always constant expressions, and so the assembler isn’t supposed to issue object code for them. Rather, it “interpreters” the expression and computes the corresponding constant result,which is what it actually emits as object code（此处说的汇编器对常量表达式的处理是“lazy”概念，exap: x &#x3D; x+3-2-1最后生成时是对 x&#x3D; x+0甚至是x&#x3D;x）</p>
</blockquote>
<h1 id="阶段1-Single-Num-expression"><a href="#阶段1-Single-Num-expression" class="headerlink" title="阶段1 Single Num expression"></a>阶段1 Single Num expression</h1><h2 id="只含”-“的二元表达式"><a href="#只含”-“的二元表达式" class="headerlink" title="只含”+-“的二元表达式"></a>只含”+-“的二元表达式</h2><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    expr::= term&lt;+-term&gt;</span></span><br><span class="line"><span class="comment">    term::=GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Expression</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term;<span class="comment">&#123;MOVE #GetNum,D0;&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;MOVE D0,D1&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: Add;<span class="comment">&#123;Match(&#x27;+&#x27;);Term;ADD D1,D0;结果存在D0&#125;</span></span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: Substract;<span class="comment">&#123;Match(&#x27;-&#x27;);Term;SUB D1,D0;NEG D0;结果存在D0&#125;</span></span><br><span class="line">    <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="多个操作数"><a href="#多个操作数" class="headerlink" title="多个操作数"></a>多个操作数</h2><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;循环解决,将数压栈解决寄存器有限&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Expression</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term;<span class="comment">&#123;MOVE #GetNum,D0;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>);<span class="comment">&#123;D1=D0;&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: Add;<span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract;<span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB -(SP),D0; NEG D0 ;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="增加”-“"><a href="#增加”-“" class="headerlink" title="增加”*&#x2F;“"></a>增加”*&#x2F;“</h2><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    优先级高，单位更小</span></span><br><span class="line"><span class="comment">    expr::= term &lt;+- term&gt;</span></span><br><span class="line"><span class="comment">    term::= factor &lt;*/ factor&gt;</span></span><br><span class="line"><span class="comment">    factor::= GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Expression</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;压栈&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="keyword">Add</span><span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB (SP)-,D0; NEG D0;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Term</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Factor<span class="punctuation">;</span><span class="comment">&#123;GetNum;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: Multiply<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;*&#x27;);Factor;MUL (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: Divide<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;乘除操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<h2 id="增加”-”"><a href="#增加”-”" class="headerlink" title="增加”()”"></a>增加”()”</h2><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">    factor ::= (expr) or GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Factor</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look =<span class="string">&#x27;(&#x27;</span> than <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE&#x27;</span>+#GetNum+<span class="string">&#x27;,D0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="增加”-作为正负号的数”"><a href="#增加”-作为正负号的数”" class="headerlink" title="增加”-+作为正负号的数”"></a>增加”-+作为正负号的数”</h2><p>增加0-</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    expr::=- or term&lt;+-term&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Expression</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;CLR D0&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;D0=0;&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        term<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;压栈&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="keyword">Add</span><span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB (SP)-,D0; NEG D0;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>


<h1 id="阶段2-Assignment（name-expression，多位数和标识符Token识别）"><a href="#阶段2-Assignment（name-expression，多位数和标识符Token识别）" class="headerlink" title="阶段2 Assignment（name &#x3D; expression，多位数和标识符Token识别）"></a>阶段2 Assignment（name &#x3D; expression，多位数和标识符Token识别）</h1><h2 id="增加-单个字母的标识符（以及无参的函数调用C语言格式）"><a href="#增加-单个字母的标识符（以及无参的函数调用C语言格式）" class="headerlink" title="增加 单个字母的标识符（以及无参的函数调用C语言格式）"></a>增加 单个字母的标识符（以及无参的函数调用C语言格式）</h2><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    factor ::= GetNum | (expre) | Ident</span></span><br><span class="line"><span class="comment">    Ident ::= GetName &lt;&#x27;(&#x27;&#x27;)&#x27;&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Factor</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look =<span class="string">&#x27;(&#x27;</span> than <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> IsAlpha(Look) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        Ident;<span class="comment">&#123;标识符识别&#125;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       EmitLn(<span class="string">&#x27;MOVE&#x27;</span>+#GetNum+<span class="string">&#x27;,D0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;----------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Ident</span>;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">Name</span>:Char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">Name</span> :=GetName;</span><br><span class="line">    <span class="keyword">if</span> Look = <span class="string">&#x27;(&#x27;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        EmitLn(<span class="string">&#x27;BSR &#x27;</span>+<span class="keyword">Name</span>);<span class="comment">&#123;调用函数&#125;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> EmitLn(<span class="string">&#x27;MOVE &#x27;</span>+<span class="keyword">Name</span>+<span class="string">&#x27;(PC),D0&#x27;</span>);<span class="comment">&#123;将操作数取出来放在D0&#125;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="增加赋值语句"><a href="#增加赋值语句" class="headerlink" title="增加赋值语句"></a>增加赋值语句</h2><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Assignment ::= GetName = expr</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Assignment</span>;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">Name</span>:char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">Name</span>:=GetName;</span><br><span class="line">    Match(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    Expression;</span><br><span class="line">    <span class="comment">&#123;赋值汇编&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;LEA &#x27;</span>+<span class="keyword">Name</span>+<span class="string">&#x27;(PC)&#x27;</span>,A0);<span class="comment">&#123;A0是地址寄存器，存放Name的地址，PC相对寻址&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;MOVE D0,(A0)&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="增加多位数和多个字母"><a href="#增加多位数和多个字母" class="headerlink" title="增加多位数和多个字母"></a>增加多位数和多个字母</h2><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    GetNum，GetName重写<span class="keyword">while</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> GetNum:<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">var</span> Value:<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Value:=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isDigit(Look) <span class="keyword">then</span> Expected(<span class="string">&#x27;Digit&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> isDigit(Look) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        Value:=Value+Look;</span><br><span class="line">        GetChar;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="增加空格过滤"><a href="#增加空格过滤" class="headerlink" title="增加空格过滤"></a>增加空格过滤</h2><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    识别空格，过滤空格，保证其余的识别开头第一个是非空格字符，即：</span><br><span class="line"></span><br><span class="line">    Init 中GetChar后要SkipWhite；</span><br><span class="line"></span><br><span class="line">    GetNum/Name 最后要SkipWhite;</span><br><span class="line">    </span><br><span class="line">    tips: LR (<span class="name">#10</span>,<span class="comment">^J</span>) CR($<span class="number">13</span>,<span class="comment">^M</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="阶段3：简单的interpreter"><a href="#阶段3：简单的interpreter" class="headerlink" title="阶段3：简单的interpreter"></a>阶段3：简单的interpreter</h1><p>interpreter就是等到必要时才打印，否则就一直计算</p>
<h2 id="识别表达式"><a href="#识别表达式" class="headerlink" title="识别表达式"></a>识别表达式</h2><figure class="highlight d"><table><tr><td class="code"><pre><span class="line">expr := -<span class="comment">/+ term &lt;+/</span>- term&gt;</span><br><span class="line">term := factor &lt;*/ factor&gt;</span><br><span class="line">factor := GetNum | (expr) </span><br></pre></td></tr></table></figure>
<h3 id="一位数字-即时计算"><a href="#一位数字-即时计算" class="headerlink" title="一位数字(即时计算)"></a>一位数字(即时计算)</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">-------------------------&#125;</span></span><br><span class="line">&#123;GetNum&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">GetNum:integer;</span></span><br><span class="line">begin</span><br><span class="line">    if not <span class="keyword">is</span>Digit(Look) <span class="keyword">then</span> Expected(<span class="symbol">&#x27;Integer</span>&#x27;);</span><br><span class="line">    GetNum := Ord(Look)-Ord(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    GetChar;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">----------------------------&#125;</span></span><br><span class="line">&#123;Factor&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Factor:integer;</span></span><br><span class="line">begin</span><br><span class="line">    if Look = &#x27;(&#x27; then</span><br><span class="line">    begin</span><br><span class="line">        Match(&#x27;(&#x27;);</span><br><span class="line">        Factor := Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> Factor := GetNum;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">-------------------------------&#125;</span></span><br><span class="line">&#123; Term &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Term:integer;</span></span><br><span class="line">var</span><br><span class="line">    Value :integer;</span><br><span class="line">begin</span><br><span class="line">    Value := Factor;</span><br><span class="line">    while <span class="keyword">is</span>Mulop(Look) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            Value:=Value * Factor;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            Value:=Value div Factor;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    Term := Value;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">-----------------------------&#125;</span></span><br><span class="line">&#123;Expression&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Expression:integer;</span></span><br><span class="line">var</span><br><span class="line">    Value:integer;</span><br><span class="line">begin</span><br><span class="line">    if <span class="keyword">is</span>Addop(Look) <span class="keyword">then</span> <span class="keyword">begin</span>&#123;能省略吗？不能因为省略后无法识别Term开头的表达式&#125;</span><br><span class="line">        Value:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> Value:= Term;</span><br><span class="line">    <span class="keyword">while</span> isAddop(Look) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            Value := Value +Term;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            Value := Value -Term;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    Expression := Value;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="多位数字-改动GetNum"><a href="#多位数字-改动GetNum" class="headerlink" title="多位数字(改动GetNum)"></a>多位数字(改动GetNum)</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">procadure GetChar;</span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">    <span class="title">Read</span><span class="params">(Look)</span></span>;</span><br><span class="line">end;</span><br><span class="line">function GetNum:integer;</span><br><span class="line">var</span><br><span class="line">    Value: integer;</span><br><span class="line">begin</span><br><span class="line">    Value :=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="keyword">not</span> <span class="title">isDigit</span><span class="params">(Look)</span> then <span class="title">Expected</span><span class="params">(<span class="string">&quot;Integer&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">isDigit</span><span class="params">(Look)</span> <span class="keyword">do</span></span></span><br><span class="line"><span class="function">    begin</span></span><br><span class="line"><span class="function">        Value :=</span> Value * <span class="number">10</span> +<span class="built_in">Ord</span>(Look)-<span class="built_in">Ord</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        GetChar;</span><br><span class="line">    end;</span><br><span class="line">    GetNum := Value;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h3 id="NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出"><a href="#NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出" class="headerlink" title="NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出"></a>NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出</h3><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    在我的电脑上windows的WSL上NewLine只用了LF</span></span><br><span class="line"><span class="comment">    结束符.</span></span><br><span class="line"><span class="comment">    输入符号表命令 ？Name Value</span></span><br><span class="line"><span class="comment">    输出符号表命令 ！Name </span></span><br><span class="line"><span class="comment">    对于WhiteSpace（在一个单元结束下一个单元开始前跳过中间的空格）：最小读取单元是数字或者单个字符，故在init的GetChar后添加skipWhite，在GetNum和GetName结束添加skipWhite（读到第一个非空格字符）,还需要在match后加上skipWhite</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123; 符号表 &#125;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">Table[<span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>] <span class="keyword">of</span> integer;</span><br><span class="line"><span class="comment">&#123; Input Table&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Input</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Match(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    <span class="keyword">Read</span>(Table[GetName]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">&#123;Output&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Output</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Match(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="keyword">Write</span>(Table[GetName]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">NewLine</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> isNewLine(Look) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            GetChar;</span><br><span class="line">            SkipWhite;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">&#123; Main &#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span> </span><br><span class="line">        <span class="string">&#x27;?&#x27;</span>: Input;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span>: Output;</span><br><span class="line">        <span class="keyword">else</span> Assignment;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        NewLine;</span><br><span class="line">        <span class="keyword">until</span> Look = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>turbo pascal</tag>
        <tag>68000 Assembly</tag>
        <tag>Jack W. Crenshaw</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>mathlib4_source_code_LinearAlgebra</title>
    <url>/2025/02/07/mathlib4-source-code-LinearAlgebra/</url>
    <content><![CDATA[<p>具有向量空间结构意味着具有加法交换群</p>
<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><ol>
<li>基础概念<br>Basis（基础）</li>
</ol>
<p>Dimension（维数）</p>
<p>FiniteDimensional（有限维）</p>
<p>FiniteDimensional.lean（有限维.lean）</p>
<p>FiniteSpan.lean（有限生成.lean）</p>
<p>Span（张成）</p>
<p>StdBasis.lean（标准基.lean）</p>
<ol start="3">
<li>矩阵与行列式<br>Matrix（矩阵）</li>
</ol>
<p>Determinant.lean（行列式.lean）</p>
<p>Vandermonde.lean（范德蒙行列式.lean）</p>
<p>Charpoly（特征多项式）</p>
<p>Trace.lean（迹.lean）</p>
<ol start="2">
<li>线性映射与线性空间<br>LinearIndependent.lean（线性无关.lean）</li>
</ol>
<p>LinearDisjoint.lean（线性无关.lean）</p>
<p>LinearPMap.lean（线性投影映射.lean）</p>
<p>Isomorphisms.lean（同构.lean）</p>
<p>Quotient（商）</p>
<p>AffineSpace（仿射空间）</p>
<ol start="4">
<li>双线性形式与二次型<br>BilinearForm（双线性形式）</li>
</ol>
<p>BilinearMap.lean（双线性映射.lean）</p>
<p>QuadraticForm（二次型）</p>
<p>SesquilinearForm.lean（半双线性型.lean）</p>
<ol start="6">
<li>特征值与特征空间<br>Eigenspace（特征空间）</li>
</ol>
<p>AnnihilatingPolynomial.lean（零化多项式.lean）</p>
<p>JordanChevalley.lean（约当-舍瓦莱.lean）</p>
<ol start="5">
<li>张量积与外代数<br>TensorProduct（张量积）</li>
</ol>
<p>TensorAlgebra（张量代数）</p>
<p>TensorPower（张量幂）</p>
<p>ExteriorAlgebra（外代数）</p>
<p>ExteriorPower（外幂）</p>
<p>PiTensorProduct.lean（π张量积.lean）</p>
<ol start="7">
<li>群与表示<br>GeneralLinearGroup.lean（一般线性群.lean）</li>
</ol>
<p>SymplecticGroup.lean（辛群.lean）</p>
<p>UnitaryGroup.lean（酉群.lean）</p>
<p>RootSystem（根系）</p>
<p>Reflection.lean（反射.lean）</p>
<ol start="8">
<li>特殊结构与定理<br>Alternating（交错）</li>
</ol>
<p>CliffordAlgebra（克利福德代数）</p>
<p>DirectSum（直和）</p>
<p>FreeModule（自由模）</p>
<p>FreeAlgebra.lean（自由代数.lean）</p>
<p>FreeProduct（自由积）</p>
<p>InvariantBasisNumber.lean（不变基数.lean）</p>
<p>PID.lean（主理想整环.lean）</p>
<p>Semisimple.lean（半单.lean）</p>
<ol start="9">
<li>几何与投影<br>Projectivization（射影化）</li>
</ol>
<p>Projection.lean（投影.lean）</p>
<p>Orientation.lean（定向.lean）</p>
<p>Ray.lean（射线.lean）</p>
<ol start="10">
<li>其他工具与辅助模块<br>DFinsupp.lean（有限支撑函数.lean）</li>
</ol>
<p>Finsupp（有限支撑）</p>
<p>Pi.lean（π.lean）</p>
<p>Prod.lean（积.lean）</p>
<p>Countable.lean（可数.lean）</p>
<p>Goursat.lean（古尔萨.lean）</p>
<p>Lagrange.lean（拉格朗日.lean）</p>
<p>PerfectPairing（完美配对）</p>
<p>SModEq.lean（模同余.lean）</p>
<p>Coevaluation.lean（余评估.lean）</p>
<p>Contraction.lean（收缩.lean）</p>
<p>CrossProduct.lean（叉积.lean）</p>
]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>theorem_proving_in_lean4</title>
    <url>/2025/01/17/theorem-proving-in-lean4/</url>
    <content><![CDATA[<p><a href="https://lean-lang.org/theorem_proving_in_lean4">theorem_proving_in_lean4</a><br>自动定理证明侧重于“发现”方面。解析定理证明器、表定理证明器、快速可满足性求解器等提供了在命题和一阶逻辑中确定公式有效性的方法。其他系统为特定语言和领域提供搜索程序和决策程序，例如整数或实数上的线性或非线性表达式。诸如 SMT（“可满足性模理论”）之类的架构将领域通用搜索方法与领域特定程序相结合。计算机代数系统和专门的数学软件包提供了执行数学计算、建立数学界限或查找数学对象的方法。计算也可以被视为证明，这些系统也有助于建立数学主张。<br>自动推理系统追求强大和高效，通常以牺牲可靠性为代价。这样的系统可能存在错误，而且很难确保它们提供的结果是正确的。相比之下，交互式定理证明侧重于定理证明的“验证”方面，要求每个主张都得到适当公理基础的证明支持。这设定了一个非常高的标准：每个推理规则和计算的每个步骤都必须通过诉诸先前的定义和定理来证明，一直到基本公理和规则。事实上，大多数这样的系统都提供了完全详尽的“证明对象”，可以传达给其他系统并进行独立检查。构建这样的证明通常需要更多的用户输入和交互，但它允许您获得更深入和更复杂的证明。<br>精益定理证明器旨在通过将自动化工具和方法置于支持用户交互和构建完全指定的公理证明的框架中来弥补交互式和自动化定理证明之间的差距。目标是同时支持数学推理和复杂系统推理，并验证这两个领域的主张。<br>Lean 的底层逻辑具有计算解释，Lean 也可以被视为一种编程语言。更确切地说，它可以被视为一种具有精确语义的程序编写系统，以及对程序计算的功能进行推理的系统。Lean 还具有充当其自己的元编程语言的机制，这意味着您可以使用 Lean 本身实现自动化并扩展 Lean 的功能.</p>
<h1 id="Dependent-Type-Theory（类型理论：任何一个表达式都是一个类型）"><a href="#Dependent-Type-Theory（类型理论：任何一个表达式都是一个类型）" class="headerlink" title="Dependent Type Theory（类型理论：任何一个表达式都是一个类型）"></a>Dependent Type Theory（类型理论：任何一个表达式都是一个类型）</h1><p>依赖类型理论的重要特征 </p>
<ol>
<li>each term has computational behavior</li>
<li>each term supports a notion of nomalization</li>
<li>term 包含很多信息，可以从中推断出信息<br>Lean 是基于依赖类型理论Calculus of Constructions，with a countable hierarchy of non-cumulative universes and inductive types，有编译器(生成可执行二进制文件)和interactive interpreter</li>
</ol>
<h2 id="Simple-Type-Theory"><a href="#Simple-Type-Theory" class="headerlink" title="Simple Type Theory"></a>Simple Type Theory</h2><p>Lean natural number is a 任意精度的无符号整数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">    def 声明new constant symbols</span><br><span class="line">    #check,#eval 辅助性命令一般#开头</span><br><span class="line">    类型理论：a -&gt; b 表示从a到b的函数类型</span><br><span class="line">    描述f是关于x的函数 f x(e.g. Nat.succ 2)</span><br><span class="line">    arrows associate to the right （Nat -&gt; Nat -&gt; Nat 是等同于Nat -&gt; (Nat -&gt; Nat)）</span><br><span class="line">    函数的partially apply： Nat.add 3等同于Nat.add 3 n 返回了一个函数等待第二个参数n</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Type-as-objects"><a href="#Type-as-objects" class="headerlink" title="Type as objects"></a>Type as objects</h2><p>不理解类型理论，不知道def定义的意思<br>不理解操作在type universes上是多态polymorphic（感觉是多个类型参数结果是一个类型）的，例子List a，表示不论a在哪个类型中，List a都有意义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Lean的底层基础无限类型层次，Type 0是小范围的类型，Type 1是更大的类型，包含Type 0作为一个元素，以此类推</span><br><span class="line">#check Type     -- Type 1</span><br><span class="line">#check Type 1   -- Type 2</span><br><span class="line">-- Lean依赖类型理论扩展的方式</span><br><span class="line">    -- 1. 类型本身，它们的类型是Type</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">-- 定义polymorphic constants（使用universe或者在定义时提供universe parameters）</span><br><span class="line">universe u</span><br><span class="line">def F (\a : Type u) : Type u := Prod \a \a</span><br><span class="line">------------------------------------------</span><br><span class="line">def G.&#123;v&#125; (\a : Type v) :Type v:= Prod \a \a</span><br></pre></td></tr></table></figure>
<h2 id="Function-Abstraction-and-Evaluation"><a href="#Function-Abstraction-and-Evaluation" class="headerlink" title="Function Abstraction and Evaluation"></a>Function Abstraction and Evaluation</h2><p>creating a function from another expression is a process known as <strong>lambda abstraction</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- fun 也可以用 λ 代替</span><br><span class="line">#check (fun x =&gt; x+1) -- Nat -&gt; Nat,此处leave off type notation省略了类型注释</span><br><span class="line">/-  fun (x : type) =&gt; t 其中()可以省略</span><br><span class="line">    对于x：\a 变量，可以构造表达式t:\b</span><br><span class="line">    λ (x: \a) =&gt; t 表示函数from \a to \b 将x 映射到t</span><br><span class="line">    其中x 是bound variable，占位符，whose scope does not extend beyond the expression t</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p><strong>alpha equivalent</strong> : expression that are the same  up to renaming of bound variables are called alpha equivalent, and considered as “the same”.</p>
<p><strong>definitionally equal</strong>： two terms that reduce to the same value are called definitionally equal</p>
<h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def self_name (arg1 arg2 : arg_Type) (arg3 :arg_type) : return_Type := expression</span><br><span class="line">-- 虽然返回类型Lean可以推断，但最好还是显示指出</span><br><span class="line">def fun1 := fun x:Nat =&gt; x+x -- def 定义函数就是有名字的fun或λ</span><br><span class="line">def fun2 (x:Nat)  : Nat := x+x</span><br><span class="line">def fun21 (x:Nat)  := x+x</span><br><span class="line"></span><br><span class="line">def fun3 : Nat -&gt; Nat := fun x =&gt; x+x</span><br><span class="line">def fun3 (x: Nat): Nat -&gt; Nat := fun x =&gt; x+x --这个第一个x会提示没有用到</span><br><span class="line">def f := 1</span><br><span class="line"></span><br><span class="line">def compose (α β γ :Type) (f: α → β ) (g : γ → α ) (x: γ ):β := f (g x)</span><br><span class="line"></span><br><span class="line">#eval compose Nat Nat Nat fun1 fun3 f --4</span><br></pre></td></tr></table></figure>
<h2 id="Local-Definitions"><a href="#Local-Definitions" class="headerlink" title="Local Definitions"></a>Local Definitions</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ;或换行都可以</span><br><span class="line">def curiosity :=</span><br><span class="line">    let x := 1+2</span><br><span class="line">    let y := x+1;let z:=y+1</span><br><span class="line">    x+y+z</span><br><span class="line">#eval curiosity -- 12</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">    ((fun a =&gt; t2) t1) 与 (let a := t1;t2)不一样；前者a是对t1的缩写，后者是a是一个变量，是一个整体</span><br><span class="line"></span><br><span class="line">    #eval (fun a:Nat =&gt; a+a) 1+1 -- 3</span><br><span class="line">    #eval (fun a:Nat =&gt; a*a) 1+1 -- 2</span><br><span class="line">    #eval (fun a:Nat =&gt; a*a) (1+1) -- 4</span><br><span class="line">    #eval let a:=1+1;a*a --4</span><br><span class="line"></span><br><span class="line">    -- 迷惑？？？：bar0会 进行type check，但是bar不会进行！！！！</span><br><span class="line">    def bar0 := let a:=Nat; fun x:a =&gt;x+2</span><br><span class="line">    def bar := (fun a =&gt; fun x : a =&gt; x + 2) Nat</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Varibles-and-Sections"><a href="#Varibles-and-Sections" class="headerlink" title="Varibles and Sections"></a>Varibles and Sections</h2><p>section可以没有名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section outer</span><br><span class="line">variable (\a \b \g :Type)</span><br><span class="line">variable (x: \a) (y: \b) --作用域在section中，包括里面的section也起作用</span><br><span class="line">section</span><br><span class="line">variable (x: \b) </span><br><span class="line">-- 与外部相同的定义会覆盖外部</span><br><span class="line">end</span><br><span class="line">end outer</span><br></pre></td></tr></table></figure>
<h2 id="NameSpaces"><a href="#NameSpaces" class="headerlink" title="NameSpaces"></a>NameSpaces</h2><p>namespase 必须有名字，有且仅有一个匿名在root level</p>
<blockquote>
<p>namespaces organize data and sections declare variables for insertion in definitions;sections are also useful for delimiting限制 the scope of commands such as “set_option” and “open”；对于variable 和 open命令，随着namespace关闭也失效</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace foo</span><br><span class="line">    namespace bar</span><br><span class="line">    end bar</span><br><span class="line">end foo</span><br><span class="line"></span><br><span class="line">open foo --可以在当前使用非嵌套foo的短名</span><br><span class="line"></span><br><span class="line">namespace foo</span><br><span class="line">end foo</span><br></pre></td></tr></table></figure>
<h2 id="What-makes-dependent-type-dependent"><a href="#What-makes-dependent-type-dependent" class="headerlink" title="What makes dependent type dependent"></a>What makes dependent type dependent</h2><p>看不懂举的例子是什么意思？？？？？？？不明白传值的时候哪个对应哪个！！！<br>type can depend on parameters<br>dependent function type(dependent arrow type) : (a:\a)-&gt;\b 其中\b 的值依赖于a (e.g. (a:\a) -&gt; \b a)</p>
<p>Dependent products are also called sigma types, and you can also write them as Σ a : α, β a. You can use ⟨a, b⟩ or Sigma.mk a b to create a dependent pair. The ⟨ and ⟩ characters may be typed with \langle and \rangle or &lt; and &gt;, respectively.</p>
<h2 id="implicit-arguments"><a href="#implicit-arguments" class="headerlink" title="implicit arguments"></a>implicit arguments</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- sorry produces a proof of anything or provides an object of any data type at all,但是不能用来证明False,会报错</span><br><span class="line">-- _  placeholder代表implicit argument，表示自动填充</span><br><span class="line">-- 可以从传入的某个参数确定一些类型参数，此时类型参数可以用_代替</span><br><span class="line"></span><br><span class="line">-- 也可以在定义时，用 &#123;&#125;将可以推断的参数括起来，在传入时就无需显示指明</span><br><span class="line"></span><br><span class="line">-- (e : T) to specify the type T of an expression e ,这样写告诉Lean的elaborator 在解决隐式参数时使用T作为e的Type</span><br><span class="line"></span><br><span class="line">--  @List  -- 描述相同的方法，不过所用的参数都变成了explicit</span><br><span class="line"></span><br><span class="line">-- Numerals are overloaded in Lean</span><br><span class="line">#check 2 -- Nat</span><br><span class="line">#check (2 : Int) -- Int</span><br></pre></td></tr></table></figure>
<p>Lean 的实例化隐式参数(instantiating implicit arguments)可以用来infer function types , predicates , proofs<br><strong>elaboration</strong> : the process of instantiating these “holes” or “placeholders”</p>
<h1 id="Propositions-and-Proofs"><a href="#Propositions-and-Proofs" class="headerlink" title="Propositions and Proofs"></a>Propositions and Proofs</h1><h2 id="Propositions-as-Types"><a href="#Propositions-as-Types" class="headerlink" title="Propositions as Types"></a>Propositions as Types</h2><p>proposition represents a sort of data type. if proposition p is true then the type associated with p  is inhabited.constructing <code>t : p</code> tell us p is indeed true.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Prop is Sort 0</span><br><span class="line">-- Type u is Sort (u+1)</span><br><span class="line">-- if p q: Prop, then p \r q :Prop</span><br><span class="line"></span><br><span class="line">-- if p : Prop , t1 t2:p 则 t1 t2是相等的</span><br><span class="line">-- (fun x =&gt; t) s and t[s/x] as definitionally equal这个后者直接写这样会报错，所以不理解</span><br></pre></td></tr></table></figure>
<h2 id="Working-with-Propositions-as-Types"><a href="#Working-with-Propositions-as-Types" class="headerlink" title="Working with Propositions as Types"></a>Working with Propositions as Types</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">    -- &#x27;theorem&#x27; command is really a version of &#x27;def&#x27; command 对于类型检查器没有任何区别 Lean tags proof as irreducible 不可归约？， which serves as a hint to the parser（elaborator）that is generally no need to unfold them when processing a file.为何不需要展开?</span><br><span class="line">    -- Lean 并行处理证明和进程，因为proof的 irrelevance，一个proof 的正确性无需另一个定理的细节</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">-- #print theorem_name -- show you the proof of a theorem</span><br><span class="line"></span><br><span class="line">-- 显示指明临时假设的类型 #show</span><br><span class="line">variable &#123;p : Prop&#125;</span><br><span class="line">variable &#123;q : Prop&#125;</span><br><span class="line">theorem t1 : p \r q \r p :=</span><br><span class="line">    fun hp : p =&gt;</span><br><span class="line">    fun hq : q =&gt;</span><br><span class="line">    show p from hp -- 原先只写 hp 就可以</span><br><span class="line"></span><br><span class="line">axiom hp : p -- 等价于声明 p is true, as witnessed by hp</span><br></pre></td></tr></table></figure>
<p>the <code>axiom</code> declaration postulates假设 the existence of an element of the given type and may compromise影响 logical consistency. </p>
<h2 id="Propositional-Logic"><a href="#Propositional-Logic" class="headerlink" title="Propositional Logic"></a>Propositional Logic</h2><p>The order of operations is as follows:<br>not &gt; and &gt; or &gt; \imp &gt; \iff其中\imp（\r）右结合<br>连接词的定义在库 Prelude.core中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- example command states a theorem without naming it or storing it in the permanent context,只是检查了term的类型</span><br><span class="line"></span><br><span class="line">--  Curry-Howard isomorphism同构：and 和 prod是一种同构</span><br><span class="line">-- 当相关类型是推纳类型且可以从context中推断出来，就可以使用Lean的匿名构造符号 \langle \rlangle 或者 \&lt; \&gt;</span><br><span class="line">#check (⟨hp, hq⟩ : p ∧ q)</span><br><span class="line"></span><br><span class="line">-- e.bar 是 Foo.bar.e 的缩写，不需要打开一个namespase</span><br><span class="line">variable (ls : List Nat)</span><br><span class="line">#check ls.length</span><br><span class="line">#check List.length ls </span><br><span class="line"></span><br><span class="line">-- for auto construction \&lt; \&gt;</span><br><span class="line">example (h : p \and q): q \and p \and q := \&lt; h.right, h \&gt;</span><br><span class="line">-- 或者 \&lt; h.right , \&lt; h.left, h.right\&gt;\&gt;</span><br><span class="line">-- 或者 And.intro h.right h -- h.left = And.left</span><br><span class="line">-- Or.elim (h :p \or q) (left :p \r c) (right :q \r c) :c简写 h.elim (left) (right)</span><br><span class="line"></span><br><span class="line">-- or 有两个构造器constructors，so 不能匿名构造，但仍然可以简写</span><br><span class="line">-- 什么是constructors？？？</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ex falso sequitur quodlibet False \r c从错误中能推出任意事实</span><br><span class="line">example (hp : p) (hnp : \neg p) : q := Flase.elim (hnp hp) -- absurd hp hnp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Introfucing-Auxilisry-Subgoals"><a href="#Introfucing-Auxilisry-Subgoals" class="headerlink" title="Introfucing Auxilisry Subgoals"></a>Introfucing Auxilisry Subgoals</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- have (h : p) := s;t 和 (fun (h : p) =&gt;t) s 是一样的；s是p的证明，t是(h:p)期望假设的证明</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">    suffices to show： resoning backwards from a goal</span><br><span class="line">-/</span><br><span class="line">    example (h : p∧ q) : q ∧ p :=</span><br><span class="line">  have hp : p := h.left</span><br><span class="line">  suffices hq:q from And.intro hq hp -- leave us with two goals,1 . by proving the original goal of q \and p with additional hypothesis hq : q, 2. have to show q</span><br><span class="line">  show q from And.right h</span><br></pre></td></tr></table></figure>
<h2 id="Classical-Logic"><a href="#Classical-Logic" class="headerlink" title="Classical Logic"></a>Classical Logic</h2><p>namespace Classical 中是典型逻辑，添加了excluded middle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open Classical</span><br><span class="line">variable (p : Prop)</span><br><span class="line">#check em p -- p ∨ ¬ p</span><br><span class="line"></span><br><span class="line">-- 反证法形式化</span><br><span class="line">#check byContradiction -- (\neg p -&gt; False) -&gt; p</span><br><span class="line">-- 通过案例</span><br><span class="line">#check byCases -- (p -&gt; q) (\neg p -&gt; q) -&gt; q</span><br></pre></td></tr></table></figure>
<h1 id="Quantifiers-And-Equality"><a href="#Quantifiers-And-Equality" class="headerlink" title="Quantifiers And Equality"></a>Quantifiers And Equality</h1><h2 id="The-Universal-Quantifier"><a href="#The-Universal-Quantifier" class="headerlink" title="The Universal Quantifier"></a>The Universal Quantifier</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- x : \a ,p x 表示 p that holds of x</span><br><span class="line">-- 任意 x : \a, p x </span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">introduction:</span><br><span class="line"></span><br><span class="line">Given a proof of p x, in a context where x : α is arbitrary, we obtain a proof ∀ x : α, p x.</span><br><span class="line"></span><br><span class="line">Given a term t of type β x, in a context where x : α is arbitrary, we have (fun x : α =&gt; t) : (x : α) → β x.</span><br><span class="line"></span><br><span class="line">elimination:</span><br><span class="line"></span><br><span class="line">Given a proof ∀ x : α, p x and any term t : α, we obtain a proof of p t.</span><br><span class="line"></span><br><span class="line">Given a term s : (x : α) → β x and any term t : α, we have s t : β t.</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p>the expressions which differ up to renaming of bound variables are considered to be equivalent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 可以都用x来表示</span><br><span class="line">example (α : Type)(p q : α → Prop): (∀ x : α , p x ∧ q x) → ∀ x : α , p x :=</span><br><span class="line">  fun (h :∀ x : α , p x ∧ q x) =&gt;</span><br><span class="line">  (fun (z : α ) =&gt;  -- 在此处重命名了变量</span><br><span class="line">  show p z from (h z).left)</span><br></pre></td></tr></table></figure>
<p>It is the typing rule for dependent arrow types, and the universal quantifier in particular, that distinguished Prop from other types.依赖箭头的类型是箭头两边的最大类型，如果箭头右边是 Sort 0类型，则依赖箭头类型就是Sort 0</p>
<blockquote>
<p>Suppose we have α : Sort i and β : Sort j, where the expression β may depend on a variable x : α. Then (x : α) → β is an element of Sort (imax i j), where imax i j is the maximum of i and j if j is not 0, and 0 otherwise.<br>Prop as the type of proposition rather than data,and it is what makes Prop <strong>impredicative</strong><br>类型的幂： Notice that if α is any type, we can form the type α → Prop of all predicates on α （the “power type of α”）</p>
</blockquote>
<h2 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a>Equality</h2><p>rfl is the notation for (Eq.refl _) 将显示参数变成了隐式参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example : 2+3 = 5 := rfl -- Eq.refl _</span><br><span class="line"></span><br><span class="line">-- Eq.subst h1 h2 &#123;motive : \a -&gt; Prop &#125;(h1 : a = b) (h2 :motive a): motive b可以用 h1 \t h2代替,Eq.subst 推断 \a -&gt; Prop 需要instanse of higher-order unification，但这个问题是不可决定的（为什么？），有时会失败，\t 更有效</span><br><span class="line"></span><br><span class="line">#check congrArg  --congrArg.&#123;u, v&#125; &#123;α : Sort u&#125; &#123;β : Sort v&#125; &#123;a₁ a₂ : α&#125; (f : α → β) (h : a₁ = a₂) : f a₁ = f a₂</span><br><span class="line">#check congrFun --congrFun.&#123;u, v&#125; &#123;α : Sort u&#125; &#123;β : α → Sort v&#125; &#123;f g : (x : α) → β x&#125; (h : f = g) (a : α) : f a = g a</span><br><span class="line">#check congr --congr.&#123;u, v&#125; &#123;α : Sort u&#125; &#123;β : Sort v&#125; &#123;f₁ f₂ : α → β&#125; &#123;a₁ a₂ : α&#125; (h₁ : f₁ = f₂) (h₂ : a₁ = a₂) : f₁ a₁ = f₂ a₂</span><br><span class="line"></span><br><span class="line">-- 乘法分配率</span><br><span class="line">    -- 左结合</span><br><span class="line">#check Nat.mul_add</span><br><span class="line">#check Nat.left_distrib -- a *(b+c) = a*b +a*c</span><br><span class="line">    -- 右结合 省略</span><br></pre></td></tr></table></figure>
<h2 id="Calculational-Proof"><a href="#Calculational-Proof" class="headerlink" title="Calculational Proof"></a>Calculational Proof</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">calc </span><br><span class="line">    &lt;expr&gt;_0 &#x27;op_1&#x27; &lt;expr&gt;_1 &#x27;:=&#x27; &lt;proof&gt;_1</span><br><span class="line">    --expr&lt;&gt;_0可以单独一行，下面用&#x27;_&#x27;</span><br><span class="line">    /-</span><br><span class="line">    &lt;expr&gt;_0 </span><br><span class="line">    &#x27;_&#x27;      &#x27;op_1&#x27; &lt;expr&gt;_1 &#x27;:=&#x27; &lt;proof&gt;_1</span><br><span class="line">    -/</span><br><span class="line">    &#x27;_&#x27;      &#x27;op_2&#x27; &lt;expr&gt;_2 &#x27;:=&#x27; &lt;proof&gt;_2</span><br><span class="line">    ...</span><br><span class="line">    &#x27;_&#x27;      &#x27;op_n&#x27; &lt;expr&gt;_n &#x27;:=&#x27; &lt;proof&gt;_n</span><br><span class="line">-- each &lt;proof&gt;_i is a proof for &lt;expr&gt;_&#123;i-1&#125; op_i &lt;expr&gt;_i</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">`rw` tactics: 重写目标</span><br><span class="line"></span><br><span class="line">use a given equality (which can be a hypothesis, a theorem name, or a complex term) to &quot;rewrite&quot; the goal. If doing so reduces the goal to an identity `t = t` ,the tatic applies reflexivity to prove it</span><br><span class="line"></span><br><span class="line">`simp` tactics:更机智的重写目标,自动选择和重复的重写</span><br><span class="line"></span><br><span class="line">rewrites the goal by applying the given identities repeatedly, in any order, anywhere they are applicable in a term. it also uses other rules that have been previously declared to the system, and applies commutativity wisely to avoid looping. </span><br><span class="line">-/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--`存在Exists.intro` : Existential introduction. If a : α and h : p a, then ⟨a, h⟩ is a proof that ∃ x : α, p x</span><br></pre></td></tr></table></figure>
<h2 id="The-Existential-Quantifier"><a href="#The-Existential-Quantifier" class="headerlink" title="The Existential Quantifier"></a>The Existential Quantifier</h2><blockquote>
<p>the library includes both an <code>introduction rule</code> and an <code>elimination rule</code><br>对于introduction rule : to prove Exists x : \a, p x, need suitable term <code>t</code> and a proof of <code>p t</code><br>只需要显示提供任意一个可取的值，以及该值下成立的假设即可，</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- set_option pp.explicit true 后使用#print 可以display implicit argument</span><br><span class="line">/-</span><br><span class="line">-- Exists.intro.&#123;u&#125; &#123;α : Sort u&#125; &#123;p : α → Prop&#125; (w : α) (h : p w) : Exists p</span><br><span class="line">-- implicit argument &#123;p : α → Prop&#125;意味着Lean能自动推出原命题，但是根据提供的值可以有很多假设：Lean use the context to infer which one is appropriate</span><br><span class="line">example : ∃ x : Nat, x &gt; 0 :=</span><br><span class="line">  have h : 1 &gt; 0 := Nat.zero_lt_succ 0</span><br><span class="line">    Exists.intro 1 h</span><br><span class="line">    -- ⟨1, h⟩</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">-- Exists.elim.&#123;u&#125; &#123;α : Sort u&#125; &#123;p : α → Prop&#125; &#123;b : Prop&#125;(h₁ : ∃ x, p x) (h₂ : ∀ (a : α), p a → b) : b</span><br><span class="line">-/</span><br><span class="line">variable (α : Type) (p q : α → Prop)</span><br><span class="line"></span><br><span class="line">example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=</span><br><span class="line">  Exists.elim h</span><br><span class="line">    (fun w =&gt;</span><br><span class="line">     fun hw : p w ∧ q w =&gt;</span><br><span class="line">     show ∃ x, q x ∧ p x from ⟨w, hw.right, hw.left⟩)</span><br><span class="line">/-`match .\a -&gt; prop.. with | ...` :拆分组件(组件自命名，可拆的数目多种多样自助)</span><br><span class="line">    the `match` statement destructs the exstential assertion into the components `w` and `hw`, which can be then used in the body of the statement to prove the proposition.</span><br><span class="line">-/</span><br><span class="line">variable (α : Type) (p q : α → Prop)</span><br><span class="line"></span><br><span class="line">example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=</span><br><span class="line">  match h with</span><br><span class="line">  | ⟨w, hw⟩ =&gt; ⟨w, hw.right, hw.left⟩</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">variable (α : Type) (p q : α → Prop)</span><br><span class="line">example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=</span><br><span class="line">  match h with</span><br><span class="line">  | ⟨w, hpw, hqw⟩ =&gt; ⟨w, hqw, hpw⟩</span><br><span class="line">  -- | ...=&gt; ...</span><br><span class="line">/- `let` : pattern-matching ,similar to `match h with | &lt;&gt; =&gt; &lt;&gt;`-/</span><br><span class="line">example &#123;α : Type&#125;&#123;p q : α → Prop&#125; (h : ∃ x ,p x ∧ q x ): ∃ x , q x ∧ p x:=</span><br><span class="line">  let ⟨ w, hpw, hqw⟩:= h</span><br><span class="line">  ⟨ w,hqw,hpw⟩</span><br></pre></td></tr></table></figure>
<h2 id="更多证明语言"><a href="#更多证明语言" class="headerlink" title="更多证明语言"></a>更多证明语言</h2><p><code>this</code> 代表上一个have匿名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">variable (f : Nat → Nat)</span><br><span class="line">variable (h : ∀ x : Nat, f x ≤ f (x + 1))</span><br><span class="line">example : f 0 ≤ f 3 :=</span><br><span class="line">  have : f 0 ≤ f 1 := h 0</span><br><span class="line">  have : f 0 ≤ f 2 := Nat.le_trans this (h 1) -- this : f 0 ≤ f 1</span><br><span class="line">  show f 0 ≤ f 3 from Nat.le_trans (by assumption) (h 2) -- (by assumption)如果目标可以inferred，就用assumption代</span><br><span class="line">  </span><br><span class="line">  -- by assumption的替代品那你，显示指出goal，notation &quot;‹&quot; p &quot;›&quot; =&gt; show p by assumption --`\f&lt; \f&gt;`</span><br><span class="line"></span><br><span class="line">example : f 0 ≥ f 1 → f 1 ≥ f 2 → f 0 = f 2 :=</span><br><span class="line">   fun p :(f 0 ≥ f 1) =&gt;</span><br><span class="line">    fun _ :(f 1 ≥ f 2) =&gt; -- 这个placeholder</span><br><span class="line">    have :  f 0 ≥ f 2 :=</span><br><span class="line">      Nat.le_trans ‹f 1 ≥ f 2 › ‹f 0 ≥ f 1 ›</span><br><span class="line">    have :f 0 ≤ f 2 :=</span><br><span class="line">      Nat.le_trans (h 0 ) (h 1)</span><br><span class="line"></span><br><span class="line">    Nat.le_antisymm this ‹f 0 ≥ f 2 ›  </span><br></pre></td></tr></table></figure>
<h1 id="Tactics"><a href="#Tactics" class="headerlink" title="Tactics"></a>Tactics</h1><p>by tactics</p>
<h2 id="Entering-Tactic-Mode"><a href="#Entering-Tactic-Mode" class="headerlink" title="Entering Tactic Mode"></a>Entering Tactic Mode</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">`exact` is a variant of `apply` ,which signals that the expression given should fill the goal exactly.</span><br><span class="line"></span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p>tatics 可能会产生多个子目标，并且tag them,可以在窗口中看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- In the case of `apply` tactic, the tags are inferred from the parameters&#x27; names used in the And.intro declaration. </span><br><span class="line"></span><br><span class="line">-- can structure your tatics using the notation `case &lt;tag&gt; =&gt; &lt;tatics&gt;`,我认为这样可以改变解决默认的解决顺序</span><br><span class="line">    -- 也可以\. 结构化证明过程</span><br><span class="line">-- And.intro &#123;a b : Prop&#125; (left : a) (right : b) : a ∧ b</span><br><span class="line">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by</span><br><span class="line">  apply And.intro</span><br><span class="line">  case right =&gt;</span><br><span class="line">    apply And.intro</span><br><span class="line">    case left =&gt; exact hq</span><br><span class="line">    case right =&gt; exact hp</span><br><span class="line">  case left =&gt; exact hp</span><br></pre></td></tr></table></figure>
<h2 id="Basic-Tactics"><a href="#Basic-Tactics" class="headerlink" title="Basic Tactics"></a>Basic Tactics</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">tactic `intro` : introduces a hypothesis, a variable of any type, is a command for constructing function abstraction interactively  (i.e., terms of the form fun x =&gt; e) 也可以像`match`一样提供多个参数,也可已使用`intros`</span><br><span class="line">intro </span><br><span class="line">| \&lt;\&gt; =&gt; ...</span><br><span class="line">| \&lt;\&gt; =&gt; ...</span><br><span class="line"></span><br><span class="line">也可以不提供任何参数：in which case, it chooses names and introduces as many variables as it can.结果是Lean自动生成名字(不能访问)，可以通过  use the combinator `unhygienic` to disable this restriction.</span><br><span class="line"></span><br><span class="line">-/</span><br><span class="line">example : ∀ a b c : Nat, a = b → a = c → c = b := by</span><br><span class="line">  intros -- 相当于跟着a✝² b✝ c✝ a✝¹ a✝ </span><br><span class="line">  rename_i a b c h1 h2</span><br><span class="line">  apply Eq.trans</span><br><span class="line">  apply Eq.symm</span><br><span class="line">  assumption</span><br><span class="line">  assumption</span><br><span class="line"></span><br><span class="line">example : ∀ a b c : Nat, a = b → a = c → c = b := by unhygienic</span><br><span class="line">  intros -- 相当于跟着 a b c a_1 a_2</span><br><span class="line">  apply Eq.trans</span><br><span class="line">  apply Eq.symm</span><br><span class="line">  exact a_2</span><br><span class="line">  exact a_1</span><br><span class="line">/-</span><br><span class="line">tactic `rename_i `:`rename_i x_1 ... x_n` :</span><br><span class="line">renames the last n inaccessible names using the given names.</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">tactic `assumption` : </span><br><span class="line">looks through the assumptions in context of the current goal, and if there is one matching the conclusion, it applies it.</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">The `rfl` tactic is syntactic sugar for `exact rfl`</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">The `revert` tactic is an reverse to `intro`, 把假设转为目标</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/-`generalize` tactic replace an arbitrary expression in the goal by a fresh variable: 将目标中的任意表达式替换成新变量 `generalize [h :]expre = variable`,但替换可能会导致goal不可证明-/</span><br><span class="line">example : 2 + 3 = 5 :=by</span><br><span class="line">  generalize h : 3 = x -- goal: 2 + x = 5</span><br><span class="line">  rw[← h] -- 2 +3 = 5已经证明完毕了</span><br><span class="line"></span><br><span class="line">/-`admit` :tactic</span><br><span class="line"> is the analogue相似 of the `sorry` tactics-/</span><br><span class="line"></span><br><span class="line">/-`cases` : </span><br><span class="line">decompose any element of an inductively defined type,子目标解决顺序任意；对于子目标使用相同策略的证明有用，和`match`的语法类似 cases h(具有多个可能值) with ,我认为区别在于match需要用函数构造，而cases直接使用tag作为函数名了</span><br><span class="line">其中h的选择：可以是某个定理名（来自库或文件），也可以是某个变量表达式</span><br><span class="line">-/</span><br><span class="line">| &lt;tag1&gt; =&gt; &lt;tactics1&gt; -- tag是Lean在声明中的参数名</span><br><span class="line">| &lt;tag2&gt; =&gt; &lt;tactics2&gt;</span><br><span class="line">-/</span><br><span class="line">  -- cases h(有多种可能) with</span><br><span class="line">  -- | inl hp =&gt; apply Or.inr hp -- inl是tag，hp是参数（根据此情况需要传入的参数）</span><br><span class="line">  -- | inr hq =&gt; apply Or.inl; exact hq</span><br><span class="line">example (p q : Prop) : p ∧ q → q ∧ p := by</span><br><span class="line">  intros h</span><br><span class="line">  cases h with</span><br><span class="line">  | intro left right =&gt; apply And.intro right left</span><br><span class="line"></span><br><span class="line">example (p q : Prop) : p ∧ q → q ∧ p := by</span><br><span class="line">  intros h</span><br><span class="line">  match h with</span><br><span class="line">  | And.intro left right =&gt; apply And.intro right left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 使用相同策略</span><br><span class="line">example (p : Prop): p ∨ p → p := by</span><br><span class="line">  intro h</span><br><span class="line">  cases h</span><br><span class="line">  repeat assumption</span><br><span class="line"></span><br><span class="line">/-combinator `tac1 &lt;;&gt; tac2` ： </span><br><span class="line">&lt;;&gt; operator provides a parallel version of the sequencing operation: tac1 is applied to the current goal, and then apply the tactic `tac2` to each subgoal produced by tactic `tac1`</span><br><span class="line">-/</span><br><span class="line">example (p : Prop) : p ∨ p → p := by</span><br><span class="line">  intro h</span><br><span class="line">  cases h &lt;;&gt; assumption</span><br><span class="line"></span><br><span class="line">/-`constructor`: apply the first applicable constructor of an inductively defined type</span><br><span class="line"></span><br><span class="line">-/</span><br><span class="line">example (p q : Prop) : p ∧ q → q ∧ p := by</span><br><span class="line">  intros h</span><br><span class="line">  match h with</span><br><span class="line">  | And.intro left right =&gt; constructor; exact right; exact left -- constructor</span><br><span class="line">example (p q : Prop) : p ∧ q → q ∧ p := by</span><br><span class="line">  intros h</span><br><span class="line">  match h with</span><br><span class="line">  | And.intro left right =&gt; constructor&lt;;&gt; assumption -- tac1 &lt;;&gt; tac2</span><br><span class="line"></span><br><span class="line">-- case and constructor</span><br><span class="line">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by</span><br><span class="line">  intros h</span><br><span class="line">  cases h with</span><br><span class="line">  | intro w hpw =&gt; constructor ; apply Or.inl; exact hpw</span><br><span class="line"></span><br><span class="line">/-`contradiction`:</span><br><span class="line">contradiction closes the main goal if its hypotheses are &quot;trivially contradictory&quot;.</span><br><span class="line">example (h : False) : q := by</span><br><span class="line">  contradiction</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">-- “combine” `intro h` with `match h ...`</span><br><span class="line">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by</span><br><span class="line">  apply Iff.intro</span><br><span class="line">  . intro h</span><br><span class="line">    match h with</span><br><span class="line">    -- 可以推断出来</span><br><span class="line">    | And.intro _ (Or.inl _) =&gt; apply Or.inl (⟨by assumption ,by assumption⟩ ) -- 自动推断 by assumption</span><br><span class="line">    | And.intro hp (Or.inr hr) =&gt; apply Or.inr (⟨hp ,hr⟩ )</span><br><span class="line">  . intro -- intro 和match 合二为一了</span><br><span class="line">    | Or.inl ⟨hp, hq⟩ =&gt; constructor; exact hp; apply Or.inl; exact hq</span><br><span class="line">    | Or.inr ⟨hp, hr⟩ =&gt; constructor; exact hp; apply Or.inr; exact hr</span><br></pre></td></tr></table></figure>
<h2 id="Structuring-Tactic-Proofs"><a href="#Structuring-Tactic-Proofs" class="headerlink" title="Structuring Tactic Proofs"></a>Structuring Tactic Proofs</h2><p><code>apply</code> and  <code>exact</code> 可以传入任意term,e.g. (using <code>have</code> <code>show</code>这两个属于 term-style的term…) can invoke tactic mode by inserting a <code>by</code> block,也有<code>show</code> 的tactic</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := </span><br><span class="line">  by intro h</span><br><span class="line">  by exact</span><br><span class="line">    have hp : p := h.left</span><br><span class="line">    have hqr : q ∨ r := h.right</span><br><span class="line">    show (p ∧ q) ∨ (p ∧ r) by -- 此处是show .. by 是term-style</span><br><span class="line">      cases hqr with</span><br><span class="line">      | inl hq =&gt; exact Or.inl ⟨hp, hq⟩</span><br><span class="line">      | inr hr =&gt; exact Or.inr ⟨hp, hr⟩</span><br><span class="line"></span><br><span class="line">/-`show` tactic:</span><br><span class="line">declares the type of the goal that is about to be solved,while remaining in tactic mode</span><br><span class="line">`show t` finds the first goal whose target unifies with t. It makes that the main goal, performs the unification, and replaces the target with the unified version of t.重写目标为定义上相等的东西</span><br><span class="line">-/</span><br><span class="line">example (n : Nat) : n + 1 = Nat.succ n := by</span><br><span class="line">  show Nat.succ n = Nat.succ n</span><br><span class="line">  rfl</span><br><span class="line"></span><br><span class="line">/-`have` tactic:</span><br><span class="line">intoduces a new subgoal,</span><br><span class="line">have name_label : xxx := ... </span><br><span class="line">1. can omit the label in the `have` tactic, in which case, the default label `this` is used</span><br><span class="line">2. can omit types in the `have` tactic </span><br><span class="line">-/ </span><br><span class="line">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by</span><br><span class="line">  intro ⟨hp, hqr⟩</span><br><span class="line">  show (p ∧ q) ∨ (p ∧ r)</span><br><span class="line">  cases hqr with</span><br><span class="line">  | inl hq =&gt;</span><br><span class="line">    have hpq: p ∧ q := And.intro hp hq-- 定义label</span><br><span class="line">    apply Or.inl</span><br><span class="line">    exact hpq</span><br><span class="line">  | inr hr =&gt;</span><br><span class="line">    have : p ∧ r := And.intro hp hr -- 省略label</span><br><span class="line">    apply Or.inr</span><br><span class="line">    exact this</span><br><span class="line"></span><br><span class="line">/-`let` tactic:</span><br><span class="line">introduce local definitions</span><br><span class="line">the difference between `let` and `have` is that `let` introduces a local definition in the contextt, so that the definition of the local declaration can be unfolded in the proof.</span><br><span class="line">-- let a : Nat := 3 * 2 -- 类型可以省略</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/- notation`.` : </span><br><span class="line">空格敏感，依赖于对齐来检测whether the tactic block ends.</span><br><span class="line"></span><br><span class="line">不用`.` 也可以使用&#123;&#125; 和 ; 来确定block</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p>看起来有结构的方式: <code>.</code> <code>case label =&gt;</code> <code>&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">apply foo</span><br><span class="line">  . &lt;proof of first goal&gt;</span><br><span class="line">  . &lt;proof of second goal&gt;</span><br><span class="line">  </span><br><span class="line">  case &lt;tag of first goal&gt;  =&gt; &lt;proof of first goal&gt;</span><br><span class="line">  case &lt;tag of second goal&gt; =&gt; &lt;proof of second goal&gt;</span><br><span class="line"> </span><br><span class="line">  &#123; &lt;proof of first goal&gt;  &#125;</span><br><span class="line">  &#123; &lt;proof of second goal&gt; &#125;</span><br><span class="line">  </span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Tactic-Combinators-are-operations-that-form-new-tactics-from-old-ones"><a href="#Tactic-Combinators-are-operations-that-form-new-tactics-from-old-ones" class="headerlink" title="Tactic Combinators( are operations that form new tactics from old ones)"></a>Tactic Combinators( are operations that form new tactics from old ones)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">The `first | t₁ | t₂ | ... | tₙ` applies each `tᵢ` until one succeeds, or else fails</span><br><span class="line"></span><br><span class="line">`skip` tactic does nothing and succeeds</span><br><span class="line"></span><br><span class="line">-/</span><br><span class="line">example (p q : Prop) (hp : p) : p ∨ q := by</span><br><span class="line">  first | apply Or.inl; assumption | apply Or.inr; assumption</span><br><span class="line"></span><br><span class="line">example (p q : Prop) (hq : q) : p ∨ q := by</span><br><span class="line">  first | apply Or.inl; assumption | apply Or.inr; assumption</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">`try` tac runs tac and succeeds even if tac failed.</span><br><span class="line">!! `repeat (try tac)` will loop forver,because `try tac` will always succeed</span><br><span class="line">-/</span><br><span class="line">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by</span><br><span class="line">  -- 第一个constructor 将goal 变为 case left : p 和 case right : q ∧ r</span><br><span class="line">  -- 第二个constructor只在case right 才会执行</span><br><span class="line">  constructor &lt;;&gt; (try constructor) &lt;;&gt; assumption</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">/-`all_goals tac` : </span><br><span class="line">applies tac to all open goals</span><br><span class="line">-/</span><br><span class="line">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by</span><br><span class="line">  constructor</span><br><span class="line">  all_goals (try constructor)</span><br><span class="line">  all_goals assumption</span><br><span class="line"></span><br><span class="line">/-`any_goals tac`:</span><br><span class="line">与`all_goal`类似，except it succeeds if its argument succeed on at least one goal</span><br><span class="line"> -/</span><br><span class="line">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by</span><br><span class="line">  repeat any_goals constructor</span><br><span class="line">  all_goals assumption</span><br><span class="line">  -- repeat (first | constructor | assumption )</span><br><span class="line"></span><br><span class="line">/-`focus t `combinator ensures that `t` only effects the current goal,temporarily hiding the others from the scope.So, if t ordinarily only effects the current goal, focus (all_goals t) has the same effect as t. </span><br><span class="line">-/</span><br><span class="line">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by</span><br><span class="line">  constructor</span><br><span class="line">  case right =&gt; constructor ; all_goals assumption</span><br><span class="line">  case left =&gt; focus (all_goals apply hp) -- 等价于 focus (apply hp)</span><br></pre></td></tr></table></figure>
<h2 id="Rewriting"><a href="#Rewriting" class="headerlink" title="Rewriting"></a>Rewriting</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-`rewrite [t]`: t is a term whose type asserts an equality.</span><br><span class="line">1. 有多个可以替换时默认选择第一个进行替换</span><br><span class="line">2. noatation `rw [t] at h` : 在h中rw</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Using-the-Simplifier"><a href="#Using-the-Simplifier" class="headerlink" title="Using the Simplifier"></a>Using the Simplifier</h2><p>A number of identities in Lean’s library have been tagged with the [simp] attribute, and the <code>simp</code> tactic uses them to iteratively rewrite subterms in an expression.也可以使用<code>at h</code>指定在h中应用<br>simp 对于交换和结合顺序的解释:the simplifier uses these two facts to rewrite an expression, as well as left commutativity. 对于local modifier告诉simplifier使用右结合， It may seem that commutativity and left-commutativity are problematic, in that repeated application of either causes looping。But the simplifier detects identities that permute their arguments, and uses a technique known as ordered rewriting.<br>也许是最后的goal会变成右结合，但simp会报错made no progress</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 例子</span><br><span class="line">example (w x y z : Nat) (p : Nat → Prop)</span><br><span class="line">        : x * y + (z * w) * x = x * w * z + y * x := by</span><br><span class="line">  simp</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-`simp`</span><br><span class="line">1. do propositional rewriting. using hypothesis p, it rewrites p ∧ q to q and p ∨ q to true</span><br><span class="line">2. 对于新的定义，也可以使用simp，可以在定义时标注 @[simp] （表示定理具有 [simp] 属性； 第二种方式是拉出来写 `attribute [simp] theorem_name`）就可以在使用`simp`时不显式指明定理</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">example (p q : Prop) (hp : p) : p ∧ q ↔ q := by</span><br><span class="line">  simp [*] -- 重写：p ∧ q = q</span><br><span class="line">example (x y z : Nat) : (x + 0) * (0 + y * 1 + z * 0) = x * y := by</span><br><span class="line">  simp -- 使用了带有simp属性的等式</span><br><span class="line"></span><br><span class="line">example (x y z : Nat) (p : Nat → Prop) (h : p (x * y))</span><br><span class="line">        : p ((x + 0) * (0 + y * 1 + z * 0)) := by</span><br><span class="line">  simp at *; assumption</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def mk_symm (xs : List α) :=</span><br><span class="line"> xs ++ xs.reverse</span><br><span class="line">theorem reverse_mk_symm (xs : List α)</span><br><span class="line">        : (mk_symm xs).reverse = mk_symm xs := by</span><br><span class="line">  simp [mk_symm]</span><br><span class="line"></span><br><span class="line">example (xs ys : List Nat)</span><br><span class="line">        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by</span><br><span class="line">  simp [reverse_mk_symm]</span><br><span class="line"></span><br><span class="line">attribute [simp] reverse_mk_symm -- 这个属性一直存在(只要导入了含有属性声明的文件，约束属性作用域的办法： using the `local` modifier)</span><br><span class="line">-- attribute [local simp] reverse_mk_symm -- 局部属性，outside the section, the simplifier will no longer use this theorem by default</span><br><span class="line"></span><br><span class="line">example (xs ys : List Nat) (p : List Nat → Prop)</span><br><span class="line">        (h : p (xs ++ mk_symm ys).reverse)</span><br><span class="line">        : p (mk_symm ys ++ xs.reverse) := by</span><br><span class="line">  simp at h; assumption</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/-“wildcard 通配符” *：</span><br><span class="line"> 代表所有的hypotheses and the goal</span><br><span class="line"> e.g. simp [*]</span><br><span class="line"> -/</span><br></pre></td></tr></table></figure>
<h2 id="Split-Tactic"><a href="#Split-Tactic" class="headerlink" title="Split Tactic"></a>Split Tactic</h2><p>The <code>split</code> tactic is useful for breaking nested if-then-else and match expressions in cases. For a match expression with n cases, the <code>split</code> tactic generates at most n subgoals.<br>拆分多种subgoal和match差不多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-`simp_arith`:</span><br><span class="line"> is shorthand for simp with arith := true and decide := true. This enables the use of normalization by linear arithmetic.</span><br><span class="line">-/</span><br><span class="line">section</span><br><span class="line">def f (x y z: Nat): Nat :=</span><br><span class="line">  match x , y ,z with</span><br><span class="line">  | 0, _, _ =&gt; y</span><br><span class="line">  | _, 0, _ =&gt; z</span><br><span class="line">  | _, _, 0 =&gt; x</span><br><span class="line">  | _, _, _ =&gt; 1</span><br><span class="line">example (x y z : Nat) : x ≠ 0 → y ≠ 0 → z ≠ 0 → z = w → f x y w = 1 := by</span><br><span class="line">  intros -- f x y w = 1</span><br><span class="line">  simp [f]    /-(match x, y, w with</span><br><span class="line">              | 0, x, x_1 =&gt; y</span><br><span class="line">              | x, 0, x_1 =&gt; w</span><br><span class="line">              | x_1, x_2, 0 =&gt; x</span><br><span class="line">              | x, x_1, x_2 =&gt; 1) =</span><br><span class="line">              1-/</span><br><span class="line">  split ;repeat (first | contradiction| rfl)</span><br><span class="line"></span><br><span class="line">  -- split &lt;;&gt; first | contradiction | rfl</span><br><span class="line"></span><br><span class="line">  -- split</span><br><span class="line">  -- case h_1 =&gt; contradiction</span><br><span class="line">  -- case h_2 =&gt; contradiction</span><br><span class="line">  -- case h_3 =&gt; contradiction</span><br><span class="line">  -- case h_4 =&gt; rfl</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>by default, <code>simp</code> include all theorems that have been marked with the attribute [simp].<br>Writing <code>simp only</code> excludes these defaults, allowing you to use a more explicitly crafted list of rules. In the examples below, the <code>minus sign</code> and <code>only</code> are used to block the application of reverse_mk_symm.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example (xs ys : List Nat) (p : List Nat → Prop)</span><br><span class="line">        (h : p (xs ++ mk_symm ys).reverse)</span><br><span class="line">        : p ((mk_symm ys).reverse ++ xs.reverse) := by</span><br><span class="line">  simp [-reverse_mk_symm] at h; assumption -- -负号</span><br><span class="line"></span><br><span class="line">example (xs ys : List Nat) (p : List Nat → Prop)</span><br><span class="line">        (h : p (xs ++ mk_symm ys).reverse)</span><br><span class="line">        : p ((mk_symm ys).reverse ++ xs.reverse) := by</span><br><span class="line">  simp only [List.reverse_append] at h; assumption -- only的应用</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-`simp` tactic 的useful configuration options:</span><br><span class="line">&#123;contextual := true, arith := true, decide := true, ...&#125;</span><br><span class="line">-/</span><br><span class="line">-- 用x= 0 化简  y + x = y ，用x ≠ 0 化简 x ≠ 0</span><br><span class="line">example : if x = 0 then y + x = y else x ≠ 0 := by</span><br><span class="line">  simp (config := &#123; contextual := true &#125;)</span><br><span class="line"></span><br><span class="line">example : 0 &lt; 1 + x ∧ x + y + 2 ≥ y + 1 := by</span><br><span class="line">  simp_arith -- is a shorthand for `simp (config := &#123;arith := true&#125;)`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Extensible-Tactics"><a href="#Extensible-Tactics" class="headerlink" title="Extensible Tactics"></a>Extensible Tactics</h2><p>command <code>syntax</code> to define new tactics<br>command <code>macro_rules</code> to specify what should be done when the new tactic is used.<br>You can provide different expansions, and the tactic interpreter will try all of them until one succeeds.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--define a new tactic `my_tac`</span><br><span class="line">syntax &quot;my_tac&quot; : tactic</span><br><span class="line">macro_rules</span><br><span class="line">  | `(tactic| my_tac)=&gt; `(tactic| assumption)</span><br><span class="line">example (h : p) : p := by</span><br><span class="line">  my_tac</span><br><span class="line"></span><br><span class="line">-- extend `my_tac`</span><br><span class="line">macro_rules</span><br><span class="line">  | `(tactic| my_tac) =&gt; `(tactic|  rfl)</span><br><span class="line"></span><br><span class="line">example (x : α ): x = x:=by my_tac</span><br><span class="line"></span><br><span class="line">-- extend `my_tac`</span><br><span class="line">macro_rules</span><br><span class="line">  | `(tactic | my_tac) =&gt; `(tactic| apply And.intro &lt;;&gt;my_tac )</span><br><span class="line">example (x : α) (h : p) : x = x ∧ p := by</span><br><span class="line">  my_tac</span><br></pre></td></tr></table></figure>
<h1 id="Interacting-with-Lean"><a href="#Interacting-with-Lean" class="headerlink" title="Interacting with Lean"></a>Interacting with Lean</h1><p>Although the names of theorems and definitions have to be unique, the aliases that identify them do not.<code>_root_</code> is an explicit description of the empty prefix.</p>
<p><code>protected</code> keyword用在定义时，可以禁止更短的别名（必须使用嵌套的全名）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- `open` 后面可以加括号指明至对于括号里面的打开命名空间,也就是可以直接使用括号里面的短别名</span><br><span class="line">open Nat (succ zero gcd)</span><br><span class="line">#check zero</span><br><span class="line">#check add -- error</span><br><span class="line">#check Nat.add --对的</span><br><span class="line"></span><br><span class="line">-- 让Nat.mul的别名为times, Nat.plus的别名为plus</span><br><span class="line">open Nat renaming mul → times, add → plus</span><br><span class="line">#eval plus (times 2 2) 3  -- 7</span><br><span class="line"></span><br><span class="line">/-`exprot`:</span><br><span class="line">在当前namespace中创建短别名，如果export在一个命名空间外使用，则创建的别名是the top level</span><br><span class="line">-/</span><br><span class="line">export Nat (succ zero gcd)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-`instance`command:</span><br><span class="line">assiggn the notation 小于等于 to some relation</span><br><span class="line">-/</span><br><span class="line">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=</span><br><span class="line">  ∃ t, l₁ ++ t = l₂</span><br><span class="line"></span><br><span class="line">instance : LE (List α) where</span><br><span class="line">  le := isPrefix</span><br><span class="line">-- 变成局部</span><br><span class="line">/-</span><br><span class="line">def instLe : LE (List α) :=</span><br><span class="line">  &#123; le := isPrefix &#125;</span><br><span class="line"></span><br><span class="line">section</span><br><span class="line">attribute [local instance] instLe</span><br><span class="line"></span><br><span class="line">example (as : List α) : as ≤ as :=</span><br><span class="line">  ⟨[], by simp⟩</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">-/</span><br><span class="line">theorem List.isPrefix_self (as : List α) : as ≤ as :=</span><br><span class="line">  ⟨[], by simp⟩</span><br></pre></td></tr></table></figure>
<h2 id="More-on-Implicit-Arguments"><a href="#More-on-Implicit-Arguments" class="headerlink" title="More on Implicit Arguments"></a>More on Implicit Arguments</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-annotion : </span><br><span class="line">`&#123;&#125;` </span><br><span class="line">`\&#123;&#123; and \&#125;&#125;` : weaker than `&#123;&#125;`,表示一个占位符应该只被添加在下一个显示参数之前</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Notation-and-Precedence"><a href="#Notation-and-Precedence" class="headerlink" title="Notation and Precedence"></a>Notation and Precedence</h2><p>语法扩展命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-introduing new `prefix` `infix` `postfix` operators-/</span><br><span class="line">infixl :  65 &quot;+&quot; =&gt; HAdd.hAdd -- 65 is the precedence level</span><br><span class="line">-- initial_command_name(describing the operator kind) : parsing precedence(natural number) : &quot;a_token&quot; =&gt; a_fuction(the operator should be translated to )</span><br><span class="line">-- 其中`precedence` 代表how &quot;tightly&quot; an operator binds to its arguments,encoding the order of operations(1024优先级可以简写为`max`)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-`notation`:</span><br><span class="line">接受一系列的tokens和命名的term placeholders with precedences</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p>(剩下的不懂)</p>
<h2 id="Coercions"><a href="#Coercions" class="headerlink" title="Coercions"></a>Coercions</h2><p>强制转换,也有自动检测和插入强制转换的机制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">variable (m n : Nat)</span><br><span class="line">variable (i j : Int)</span><br><span class="line">#check (m + i) --↑m + i : Int</span><br><span class="line">#check Int.ofNat m -- Int</span><br></pre></td></tr></table></figure>
<h2 id="Displaying-Information"><a href="#Displaying-Information" class="headerlink" title="Displaying Information"></a>Displaying Information</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#check @Eq</span><br><span class="line">#print -- (展示type of the symbol and definition of a definition or theorem; 展示indicates that fact, and shows the type of a constant or an axiom)</span><br></pre></td></tr></table></figure>
<h2 id="Setting-Options"><a href="#Setting-Options" class="headerlink" title="Setting Options"></a>Setting Options</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- set_option &lt;name&gt; &lt;value&gt;</span><br><span class="line">-- `set_option pp.all true` carries out these settings all at once, whereas `set_option pp.all` false reverts to the previous values.</span><br><span class="line">-- pp.notation :使用defined notation to display output</span><br></pre></td></tr></table></figure>
<h2 id="Using-the-Library"><a href="#Using-the-Library" class="headerlink" title="Using the Library"></a>Using the Library</h2><p>import 可以传递，But the act of opening a namespace, which provides shorter names, does not carry over. In each file, you need to open the namespaces you wish to use.<br><a href="https://github.com/leanprover/lean4/tree/master/src/Init">标准库1</a><br><a href="https://github.com/leanprover/std4/tree/main/Std">Lean4标准库2</a></p>
<h2 id="Auto-Bound-Implicit-Arguments"><a href="#Auto-Bound-Implicit-Arguments" class="headerlink" title="Auto Bound Implicit Arguments"></a>Auto Bound Implicit Arguments</h2><p>Lean4 的新特性: 对于是single lower case or greek letter的未绑定标识符，Lean会自动绑定为implicit argument<br>可以通过<code>set_option autoImplicit false</code>禁止此特性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Sort 类型比Type更general</span><br><span class="line">def compose (g : β → γ) (f : α → β) (x : α) : γ :=</span><br><span class="line">  g (f x)</span><br><span class="line"></span><br><span class="line">#check @compose</span><br><span class="line">-- &#123;β : Sort u_1&#125; → &#123;γ : Sort u_2&#125; → &#123;α : Sort u_3&#125; → (β → γ) → (α → β) → α → γ</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Implicit-Lambdas"><a href="#Implicit-Lambdas" class="headerlink" title="Implicit Lambdas"></a>Implicit Lambdas</h2><p>在fun 的语法中，也可以使用{} 表示隐式参数,@fun 就必须传入所有（显式和隐式）参数</p>
<h2 id="Sugar-for-Simple-Functions"><a href="#Sugar-for-Simple-Functions" class="headerlink" title="Sugar for Simple Functions"></a>Sugar for Simple Functions</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 在Lean4中对于中缀操作符：使用 · as a placeholder</span><br><span class="line">#check (· + 1)</span><br><span class="line">-- fun a =&gt; a + 1</span><br><span class="line">#check (2 - ·)</span><br><span class="line">-- fun a =&gt; 2 - a</span><br><span class="line">#eval [1, 2, 3, 4, 5].foldl (·*·) 1</span><br><span class="line">-- 120</span><br><span class="line"></span><br><span class="line">def f (x y z : Nat) :=</span><br><span class="line">  x + y + z</span><br><span class="line"></span><br><span class="line">#check (f · 1 ·)</span><br><span class="line">-- fun a b =&gt; f a 1 b</span><br><span class="line"></span><br><span class="line">#eval [(1, 2), (3, 4), (5, 6)].map (·.1)</span><br><span class="line">-- [1, 3, 5]</span><br><span class="line"></span><br><span class="line">-- 需要括号打断· 和 ·</span><br><span class="line">#check (Prod.mk · (· + 1)) --fun x =&gt; (x, fun x =&gt; x + 1) : ?m.49894 → ?m.49894 × (Nat → Nat)</span><br></pre></td></tr></table></figure>
<h2 id="Named-Arguments"><a href="#Named-Arguments" class="headerlink" title="Named Arguments"></a>Named Arguments</h2><p>命名参数用来不按顺序传参，provide the value for an implicit parameter when lean failed to infer it.<br>可以使用<code>..</code> to provide missing explicit arguments as <code>_</code>,前提是这些显示参数是Lean可以自动推断出来</p>
<h1 id="Inductive-Types"><a href="#Inductive-Types" class="headerlink" title="Inductive Types"></a>Inductive Types</h1><p>具体类型(除了universes)和类型构造器(除了dependent arrows)都是inductive types的实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Inductive type is built up from a specified list of constructors</span><br><span class="line">inductive Foo where</span><br><span class="line">  | constructor₁ : ... → Foo</span><br><span class="line">  | constructor₂ : ... → Foo</span><br><span class="line">  ...</span><br><span class="line">  | constructorₙ : ... → Foo</span><br></pre></td></tr></table></figure>
<h2 id="Enumerated-Types"><a href="#Enumerated-Types" class="headerlink" title="Enumerated Types"></a>Enumerated Types</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-使用match expression定义Weekday的函数-/</span><br><span class="line">inductive Weekday where</span><br><span class="line"> | sunday : Weekday</span><br><span class="line"> | monday : Weekday</span><br><span class="line"> | tuesday : Weekday</span><br><span class="line"> | wednesday : Weekday</span><br><span class="line"> | thursday : Weekday</span><br><span class="line"> | friday : Weekday</span><br><span class="line"> | saturday : Weekday</span><br><span class="line"> deriving Repr -- instruct Lean to generate a function that converts Weekday objects into text.</span><br><span class="line">open Weekday</span><br><span class="line"></span><br><span class="line">def numberOfDay (d : Weekday) : Nat :=</span><br><span class="line">  match d with</span><br><span class="line">  | sunday    =&gt; 1</span><br><span class="line">  | monday    =&gt; 2</span><br><span class="line">  | tuesday   =&gt; 3</span><br><span class="line">  | wednesday =&gt; 4</span><br><span class="line">  | thursday  =&gt; 5</span><br><span class="line">  | friday    =&gt; 6</span><br><span class="line">  | saturday  =&gt; 7</span><br><span class="line"></span><br><span class="line">#eval numberOfDay Weekday.sunday  -- 1</span><br><span class="line">#eval numberOfDay Weekday.monday  -- 2</span><br><span class="line"></span><br><span class="line">/-使用match定义函数：-/</span><br><span class="line">namespace Hidden</span><br><span class="line">def and (a b : Bool) : Bool :=</span><br><span class="line">  match a with</span><br><span class="line">  | true  =&gt; b</span><br><span class="line">  | false =&gt; false</span><br><span class="line">end Hidden</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Constructors-With-Arguments"><a href="#Constructors-With-Arguments" class="headerlink" title="Constructors With Arguments"></a>Constructors With Arguments</h2><p>Remember that the standard library defines notation α × β for Prod α β and (a, b) for Prod.mk a b.</p>
<p>Notice that the product type depends on parameters α β : Type which are arguments to the constructors as well as Prod. Lean detects when these arguments can be inferred from later arguments to a constructor or the return type, and makes them implicit in that case.<br>Lean 可以自动推断参数类型后使其隐式化</p>
<blockquote>
<p>in this section : each constructor relies only on previously specified types.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inductive Prod (α : Type u)(β : Type v)</span><br><span class="line">| mk  (a :α) (b :β)   : Prod α β -- 可以对参数命名</span><br><span class="line">-- mk : α → β → Prod α β</span><br></pre></td></tr></table></figure>

<p>A type, like Prod, that has only one constructor is purely conjunctive ：the constructor simply packs the list of arguments into a single piece of data, essentially a tuple where the type of subsequent arguments can depend on the type of the initial argument. We can also think of such a type as a “record” or a “structure”. In Lean, the keyword structure can be used to define such an inductive type as well as its projections, at the same time.只有一个构造器的纯粹or类型：将参数打包成一个数据，后续参数都依赖于第一个参数, 这样的类型可以看作是record或者structure</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">介绍了</span><br><span class="line">1. inductive type : Prod</span><br><span class="line">2. mk : constructor</span><br><span class="line">3. fst , snd : projections</span><br><span class="line">4. eliminators `rec` `recOn`</span><br><span class="line">-/</span><br><span class="line">structure Prod (α : Type u) (β : Type v) where</span><br><span class="line">  mk :: (fst : α) (snd : β)</span><br><span class="line"></span><br><span class="line">structure Color where</span><br><span class="line">  (red : Nat)(green : Nat)(blue : Nat) -- 不用()用换行也行</span><br><span class="line">  deriving Repr</span><br><span class="line"></span><br><span class="line">-- dependent Product sugma </span><br><span class="line">-- Sigma.mk.&#123;u, v&#125; &#123;α : Type u&#125; &#123;β : α → Type v&#125; (fst : α) (snd : β fst) : Sigma β</span><br><span class="line">namespace Hidden</span><br><span class="line">inductive Sigma &#123;α : Type u&#125; (β : α → Type v) where</span><br><span class="line">  | mk : (a : α) → β a → Sigma β</span><br><span class="line">end Hidden</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Inductively-Defined-Propositions"><a href="#Inductively-Defined-Propositions" class="headerlink" title="Inductively Defined Propositions"></a>Inductively Defined Propositions</h2><p>归纳类型定义的类型可以生存在任何类型的universe中，包括Prop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inductive Or (a b: Prop) where</span><br><span class="line">| inl : a -&gt; Or a b </span><br><span class="line">| inr : b -&gt; Or a b</span><br></pre></td></tr></table></figure>
<p>Roughly speaking, what characterizes inductive types in Prop is that one can only eliminate to other types in Prop. This is consistent with the understanding that if <code>p : Prop</code>, an element <code>hp : p</code> carries no data.</p>
<p><code> ∃ x : α, p is syntactic sugar for Exists (fun x : α =&gt; p).</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inductive Exists &#123;α : Type u&#125; (p : α → Prop) where</span><br><span class="line">  | intro (w : α) (hw : p w) : Exists p</span><br></pre></td></tr></table></figure>

<p>The notation <code>&#123;x : α // p x&#125;</code>也表示一个类型 is syntactic sugar for <code>Subtype (fun x : α =&gt; p x)</code>表示对所有的x \a，p x都成立. It is modeled after subset notation in set theory: the idea is that {x : α &#x2F;&#x2F; p x} denotes the collection of elements of α that have property p.</p>
<h2 id="Defining-the-Natural-Numbers"><a href="#Defining-the-Natural-Numbers" class="headerlink" title="Defining the Natural Numbers"></a>Defining the Natural Numbers</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inductive Nat where</span><br><span class="line">  | zero : Nat</span><br><span class="line">  | succ : Nat → Nat</span><br><span class="line">  deriving Repr</span><br><span class="line"></span><br><span class="line">def add (a   b : Nat): Nat :=</span><br><span class="line">  match a with</span><br><span class="line">  | Nat.zero =&gt; b</span><br><span class="line">  | Nat.succ a&#x27; =&gt; Nat.succ (add a&#x27; b)</span><br><span class="line"></span><br><span class="line">-- 归纳证明例子</span><br><span class="line">open Nat</span><br><span class="line">theorem add_comm (m n : Nat) : m + n = n + m :=</span><br><span class="line">  Nat.recOn (motive := fun x =&gt; m + x = x + m) n</span><br><span class="line">   (show m + 0 = 0 + m by rw [Nat.zero_add, Nat.add_zero])</span><br><span class="line">   (fun (n : Nat) (ih : m + n = n + m) =&gt;</span><br><span class="line">    show m + succ n = succ n + m from</span><br><span class="line">    calc m + succ n</span><br><span class="line">      _ = succ (m + n) := rfl</span><br><span class="line">      _ = succ (n + m) := by rw [ih]</span><br><span class="line">      _ = succ n + m   := sorry)</span><br><span class="line"></span><br><span class="line">-- sorry 处依旧可以用归纳证明 succ n + 0,  succ n + succ m</span><br></pre></td></tr></table></figure>
<h2 id="Other-Recursive-Data-Types"><a href="#Other-Recursive-Data-Types" class="headerlink" title="Other Recursive Data Types"></a>Other Recursive Data Types</h2><h2 id="Inductive-Types-with-Parameters"><a href="#Inductive-Types-with-Parameters" class="headerlink" title="Inductive Types with Parameters"></a>Inductive Types with Parameters</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inductive List (α : Type u) where</span><br><span class="line">  | nil : List α</span><br><span class="line">  | cons : α → List α → List α</span><br></pre></td></tr></table></figure>
<h2 id="Inductive-Types-with-Recursion"><a href="#Inductive-Types-with-Recursion" class="headerlink" title="Inductive Types with Recursion"></a>Inductive Types with Recursion</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Tactics-for-Inductive-Types"><a href="#Tactics-for-Inductive-Types" class="headerlink" title="Tactics for Inductive Types"></a>Tactics for Inductive Types</h2><p>cases (当open Classical, can use the law of the exclude middle for any proposition at all),</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 排中律Decidable.em</span><br><span class="line">theorem em (p : Prop) [Decidable p] : p ∨ ¬p :=</span><br><span class="line">  byCases Or.inl Or.inr</span><br></pre></td></tr></table></figure>
<p><code>induction</code> tactic: 用来归纳证明</p>
<ol>
<li>证明归纳</li>
<li>支持 user-defined induction principle with multiple targets<br>语法与cases一样，except that the argument can only be a term in the <code>local context</code>,也可以用<code>case</code> 替换 <code>|</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theorem zero_add (n : Nat) : 0 + n = n := by</span><br><span class="line">  induction n with</span><br><span class="line">  | zero =&gt; rfl -- case zero =&gt; rfl</span><br><span class="line">  | succ n ih =&gt; rw [Nat.add_succ, ih]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-`funext` tactic:</span><br><span class="line"></span><br><span class="line">-/</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Inductive-Families"><a href="#Inductive-Families" class="headerlink" title="Inductive Families"></a>Inductive Families</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 其中...表示一系列的参数类型，叫做`indices`</span><br><span class="line">inductive foo : ... → Sort u where</span><br><span class="line">  | constructor1 : ... → foo ...</span><br><span class="line">  | constructor₂ : ... → foo ...</span><br><span class="line">  ...</span><br><span class="line">  | constructorₙ : ... → foo ...</span><br></pre></td></tr></table></figure>
<h2 id="Axiomatic-Details"><a href="#Axiomatic-Details" class="headerlink" title="Axiomatic Details"></a>Axiomatic Details</h2><h2 id="Mutual-and-Nested-Inductive-Types"><a href="#Mutual-and-Nested-Inductive-Types" class="headerlink" title="Mutual and Nested Inductive Types"></a>Mutual and Nested Inductive Types</h2><p>mutual: 同时定义两个，相互关联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutual</span><br><span class="line">    inductive Tree (α : Type u) where</span><br><span class="line">      | node : α → TreeList α → Tree α</span><br><span class="line"></span><br><span class="line">    inductive TreeList (α : Type u) where</span><br><span class="line">      | nil  : TreeList α</span><br><span class="line">      | cons : Tree α → TreeList α → TreeList α</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Nested : 使用其他type</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inductive Tree (α : Type u) where</span><br><span class="line">  | mk : α → List (Tree α) → Tree α -- 用List(Tree \a )代替TreeList </span><br></pre></td></tr></table></figure>
<h1 id="Induction-and-Recursion"><a href="#Induction-and-Recursion" class="headerlink" title="Induction and Recursion"></a>Induction and Recursion</h1><h2 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-`zero` and `succ` notation 具有 [match_pattern] attribute, they can be used in pattern matching</span><br><span class="line">-/</span><br><span class="line">-- def的多cases形式</span><br><span class="line">def sub1 : Nat → Nat</span><br><span class="line">  | zero   =&gt; zero</span><br><span class="line">  | succ x =&gt; x</span><br><span class="line">-- 不用zero和succ</span><br><span class="line">def sub1&#x27; : Nat → Nat</span><br><span class="line">  | 0 =&gt; 0</span><br><span class="line">  | x +1 =&gt; x</span><br></pre></td></tr></table></figure>
<p>认为模式匹配是多情况定义<br>Pattern matching works with any inductive type, such as products and option types<br><code>fun_name.match_1</code>:看定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 一个参数示例</span><br><span class="line">def sub2 : Nat → Nat</span><br><span class="line">  | zero =&gt; 0</span><br><span class="line">  | succ zero =&gt; 0</span><br><span class="line">  | succ (x + 1)=&gt; x</span><br><span class="line">#check sub2.match_1 -- 这里面写出了sub2的完整定义</span><br><span class="line">#check sub2 -- Nat →  Nat</span><br><span class="line"></span><br><span class="line">def sub2&#x27; : Nat → Nat :=</span><br><span class="line">  fun x =&gt;</span><br><span class="line">  match x with</span><br><span class="line">  | zero =&gt; 0</span><br><span class="line">  | 1 =&gt; 0</span><br><span class="line">  | x + 2 =&gt; x</span><br><span class="line"></span><br><span class="line">-- 两个参数示例</span><br><span class="line">def foo : Nat → Nat → Nat</span><br><span class="line">  | 0,   n   =&gt; 0</span><br><span class="line">  | m+1, 0   =&gt; 1</span><br><span class="line">  | m+1, n+1 =&gt; 2</span><br><span class="line">-- 只对一个参数模式匹配</span><br><span class="line">def and : Bool → Bool → Bool</span><br><span class="line">  | true, a=&gt; a</span><br><span class="line">  | false , _ =&gt; false -- 这里的_表示wildcard pattern或者匿名变量，并不代表implicit argument</span><br><span class="line"></span><br><span class="line">/-出现在`:` 之前的参数不参与pattern matching，Lean also allows parameters to occur after `:`,but it cannot pattern match on them-/</span><br><span class="line">-- α 不参与 pattern matching</span><br><span class="line">def tail1 &#123;α : Type u&#125; : List α → List α</span><br><span class="line">  | []      =&gt; []</span><br><span class="line">  | a :: as =&gt; as</span><br><span class="line">-- α也没有参与 pattern matching，只对list进行了分割</span><br><span class="line">def tail2 : &#123;α : Type u&#125; → List α → List α</span><br><span class="line">  | α, []      =&gt; []</span><br><span class="line">  | α, a :: as =&gt; as</span><br></pre></td></tr></table></figure>
<h2 id="Wildcards-and-Overlapping-Patterns"><a href="#Wildcards-and-Overlapping-Patterns" class="headerlink" title="Wildcards and Overlapping Patterns"></a>Wildcards and Overlapping Patterns</h2><p>the notion of a wildcard</p>
<p>对于patterns overlap的情况，Lean use the first applicable equation</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo : Nat → Nat → Nat</span><br><span class="line">  | 0,   n   =&gt; 0</span><br><span class="line">  | m, 0   =&gt; 1</span><br><span class="line">  | m, n =&gt; 2</span><br><span class="line"></span><br><span class="line">-- `_`作为通配符</span><br><span class="line">def foo : Nat → Nat → Nat</span><br><span class="line">  | 0,   _   =&gt; 0-- m n 的值没有用到，可以写成_</span><br><span class="line">  | _, 0   =&gt; 1</span><br><span class="line">  | _, _ =&gt; default -- default是Inhabited类型的默认值</span><br></pre></td></tr></table></figure>
<p>function programming languages support <code>incomplete patterns</code>.We can simulate the arbitrary value approch using the <code>Inhabited</code> type class.</p>
<p>we will see that Lean can be instructed that suitable base types are inhabited, and can automatically infer that other constructed types are inhabited. On this basis, the standard library provides a default element, <code>default</code>, of any inhabited type.inhabited 类型有默认值，可以传递?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-`Option`: simulate the incomplete patterns.The idea is to return `some a`for the provided patterns, and use `none` for the incomplete cases</span><br><span class="line"></span><br><span class="line">-/</span><br><span class="line">def f2 : Nat → Nat → Option Nat</span><br><span class="line">  | 0, _  =&gt; some 1</span><br><span class="line">  | _, 0  =&gt; some 2</span><br><span class="line">  | _, _  =&gt; none     -- the &quot;incomplete&quot; case</span><br></pre></td></tr></table></figure>
<h2 id="Structural-Recursion-and-Induction"><a href="#Structural-Recursion-and-Induction" class="headerlink" title="Structural Recursion and Induction"></a>Structural Recursion and Induction</h2><ol>
<li>structurally recursive definitions</li>
<li>well-founded recursive definitions</li>
<li>mutually recursive definitions<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 模式匹配</span><br><span class="line">/-</span><br><span class="line">As we have seen, a `pattern` is either a variable, a constructor applied to other patterns, or an expression that normalizes to something of that form (where the non-constructors are marked with the [match_pattern] attribute). The appearances of constructors prompt case splits, with the arguments to the constructors represented by the given variables.</span><br><span class="line">`pattern`:</span><br><span class="line">1. 变量</span><br><span class="line">2. 构造器</span><br><span class="line">3. 表达式</span><br><span class="line">4.  explicit terms in patterns that are needed to make an expression type check，though they do not play a role in pattern matching. These are called &quot;inaccessible patterns&quot; for that reason. </span><br><span class="line">-/</span><br><span class="line">def foo (a : α) : (b : β) → γ</span><br><span class="line">  | [patterns₁] =&gt; t₁</span><br><span class="line">  ...</span><br><span class="line">  | [patternsₙ] =&gt; tₙ</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In other situations, however, reductions hold only propositionally, which is to say, they are equational theorems that must be applied explicitly. The equation compiler generates such theorems internally. They are not meant to be used directly by the user; rather, the <code>simp</code> tactic is configured to use them when necessary.</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theorem zero_add : ∀ n, add zero n = n</span><br><span class="line">  | zero =&gt; rfl</span><br><span class="line">  | succ n =&gt; congrArg succ (zero_add n) -- 递归</span><br><span class="line">  -- | succ n =&gt; by simp [add, zero_add] </span><br><span class="line">-- 要证明 add zero (succ n) = succ n  =&gt;</span><br><span class="line">--f :=succ x = x + 1;</span><br><span class="line">-- h:=  add zero n = n 结果 succ (add zero n)  = succ n</span><br><span class="line">-- 另一种写法</span><br><span class="line">theorem zero_add : ∀ n, add zero n = n</span><br><span class="line">  | zero =&gt; by simp [add]</span><br><span class="line">  | succ n =&gt; by rw[add, zero_add]</span><br></pre></td></tr></table></figure>
<p>与模式匹配的定义一样：parameters to a structural recursion or induction 可能出现在冒号之前Such parameters are simply added to the local context before the definition is processed</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open Nat</span><br><span class="line">def add (m : Nat) : Nat → Nat</span><br><span class="line">  | zero =&gt; m</span><br><span class="line">  | succ n =&gt; succ (add m n)</span><br><span class="line"></span><br><span class="line">-- 也可以使用match</span><br><span class="line">def add&#x27; (m n: Nat) :  Nat :=</span><br><span class="line">  match n with</span><br><span class="line">  | zero =&gt; m</span><br><span class="line">  | succ n =&gt; succ (add m n)</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">`let rec`和`where`在`def`中的应用</span><br><span class="line">-/</span><br><span class="line">def fibFast (n : Nat) : Nat :=</span><br><span class="line">  (loop n).2</span><br><span class="line">where</span><br><span class="line">  loop : Nat → Nat × Nat</span><br><span class="line">    | 0   =&gt; (0, 1)</span><br><span class="line">    | n+1 =&gt; let p := loop n; (p.2, p.1 + p.2)</span><br><span class="line"></span><br><span class="line">def fibFast&#x27; (n : Nat): Nat:=</span><br><span class="line">  let rec loop : Nat → Nat × Nat</span><br><span class="line">    | 0 =&gt; (0,1)</span><br><span class="line">    | n + 1 =&gt; let p := loop n; (p.2, p.2 + p.1)</span><br><span class="line">  (loop n).2</span><br><span class="line"></span><br><span class="line">/-`below` `brecOn`介绍：</span><br><span class="line">To handle structural recursion, the equation compiler uses course-of-values recursion, using constants below and brecOn that are automatically generated with each inductively defined type</span><br><span class="line">-/</span><br><span class="line">variable (C : Nat → Type u)</span><br><span class="line"></span><br><span class="line">#check (@Nat.below C : Nat → Type u)</span><br><span class="line"></span><br><span class="line">#reduce @Nat.below C (3 : Nat)-- 存储C 0， C 1， C 2元素的数据结构</span><br><span class="line"></span><br><span class="line">-- 下面是值过程递归的例子</span><br><span class="line">#check (@Nat.brecOn C : (n : Nat) → ((n : Nat) → @Nat.below C n → C n) → C n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The use of course-of-values recursion is one of the techniques the equation compiler uses to justify to the Lean kernel that a function terminates. It does not affect the code generator which compiles recursive functions as other functional programming language compilers. Recall that <code>#eval fib &lt;n&gt; </code>is exponential on <n>. On the other hand, <code>#reduce fib &lt;n&gt; </code>is efficient because it uses the definition sent to the kernel that is based on the <code>brecOn </code>construction.brecOn的实现可能更有效率</p>
</blockquote>
<p>– 不懂！ 这里面的<code>::</code>是什么语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def append : List α → List α → List α</span><br><span class="line">  | [] , bs =&gt; bs</span><br><span class="line">  | a :: as , bs =&gt; a :: append as bs</span><br></pre></td></tr></table></figure>
<h2 id="Local-recursive-declarations"><a href="#Local-recursive-declarations" class="headerlink" title="Local recursive declarations"></a>Local recursive declarations</h2><p><code>let ret</code>定义local recursive</p>
<h2 id="Inaccessible-Patterns"><a href="#Inaccessible-Patterns" class="headerlink" title="Inaccessible Patterns"></a>Inaccessible Patterns</h2><p>use implicit arguments in patterns </p>
<h1 id="Structure-and-Records"><a href="#Structure-and-Records" class="headerlink" title="Structure and Records"></a>Structure and Records</h1><h1 id="Type-Classes"><a href="#Type-Classes" class="headerlink" title="Type Classes"></a>Type Classes</h1>]]></content>
      <categories>
        <category>Lean</category>
      </categories>
      <tags>
        <tag>Lean</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题</title>
    <url>/2024/10/05/hello-world/</url>
    <content><![CDATA[<h2 id="指路Next入门教程"><a href="#指路Next入门教程" class="headerlink" title="指路Next入门教程"></a><a href="https://hexo-next.readthedocs.io/zh-cn/latest/next/">指路Next入门教程</a></h2>]]></content>
      <categories>
        <category>Hexo-Next</category>
      </categories>
      <tags>
        <tag>Beautify</tag>
      </tags>
  </entry>
</search>
