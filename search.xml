<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lean4</title>
    <url>/2024/12/31/Lean4/</url>
    <content><![CDATA[<p>Lean4：被称为交互式定理证明器（interactive theorem-proving system）的计算机系统（也称为证明助手或形式化系统）提供了另一种表达数学论证的方法。<br>mathlib(Lean mathematical library)是一项由社区推动的工作，旨在建立一个以lean proof assistant形式化的统一数学库。<br>a proof assistant：(一个软件，提供规范语言，依照规范语言定义对象和性质，证明定理，系统检查定理的正确性，直至逻辑基础)<br>Formalization:  我们将用一种规范的语言（如编程语言）来书写数学定义、定理和证明，让 Lean 能够理解。 作为回报，Lean 会提供反馈和信息，解释表达式并保证其格式正确，并最终认证我们证明的正确性。</p>
<p>Lean 是一个工具将复杂表达式转换成形式化语言(dependent type theory)</p>
]]></content>
  </entry>
  <entry>
    <title>Mathematics_in_Lean</title>
    <url>/2025/01/02/Mathematics-in-Lean/</url>
    <content><![CDATA[<p>Mathematics in lean ：基于mathlib库，建造复杂表达式的方式：1.自己写，2.提供instruction 指导如何构建<br>Theorem Proving in Lean: 侧重底层逻辑框架和Lean的核心语法</p>
<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><h2 id="2-basic"><a href="#2-basic" class="headerlink" title="2 basic"></a>2 basic</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- le_div_iff₀这个theorem，以及rm[]</span><br><span class="line">-- 使用方面linarith(线性计算)，和ring(交换)</span><br><span class="line">-- 以及证明时可以把用的定理直接提出来，theorem</span><br><span class="line">-- have h:引入假设，calc 分步计算，让过程更加清晰，因为写出了要证明的每一步的结果</span><br><span class="line">-- tatics： apply , repeat</span><br></pre></td></tr></table></figure>
<h2 id="3-1-Impication-and-the-Universal-Quantifier"><a href="#3-1-Impication-and-the-Universal-Quantifier" class="headerlink" title="3.1 Impication and the Universal Quantifier"></a>3.1 Impication and the Universal Quantifier</h2><p>In lean,in a sequence of implications there are implicit parentheses grouped to the right. </p>
<p>it is common in Lean to use curly brackets to make quantified variables implicit when they can be inferred from subsequent hypotheses.So we can just do lemma to the hypothese without mentioning the objects.即用{}括起来的在调用时不需要显示指出。</p>
<h2 id="5-2-Induction-and-Recursion"><a href="#5-2-Induction-and-Recursion" class="headerlink" title="5.2 Induction and Recursion"></a>5.2 Induction and Recursion</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 归纳</span><br><span class="line">-- inductive types (which are types generated infuctively by a given list of constructors)</span><br><span class="line">-- e.g. the natual numbers are declared as follows( in Prelude.lean)</span><br><span class="line">inductive Nat where</span><br><span class="line">  | zero : Nat -- constructor</span><br><span class="line">  | succ (n : Nat): Nat -- constructor</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">@[simp] -- specifys that the defining equation should be added to the database of identities that the simplifier uses by default</span><br></pre></td></tr></table></figure>

<h2 id="6-1-Defining-Structures"><a href="#6-1-Defining-Structures" class="headerlink" title="6.1 Defining Structures"></a>6.1 Defining Structures</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">structure structure_name where</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h3 id="annotation-when-define-a-structure："><a href="#annotation-when-define-a-structure：" class="headerlink" title="annotation when define a structure："></a>annotation when define a structure：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@[ext] -- extensionality,tells Lean to automatically generate theorems that can be used to prove that two instances of a structure are equal when their components are equal.</span><br></pre></td></tr></table></figure>
<h3 id="define-particular-instances-of-structure"><a href="#define-particular-instances-of-structure" class="headerlink" title="define particular instances of structure"></a>define particular instances of structure</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def inst_name : struc_name where</span><br><span class="line">  ...</span><br><span class="line">  -- e.g. x:=1</span><br><span class="line">---------------------------------</span><br><span class="line">def inst_name : struct_name :=</span><br><span class="line">  ...</span><br><span class="line">  --e.g. &lt;value1 , ,...&gt; -- anonymous constructor notation</span><br><span class="line">---------------------------------</span><br><span class="line">def inst_name :=</span><br><span class="line">  struc_name.mk ...valuek valuek+1 ...</span><br><span class="line">  -- struc_name.mk 是constructor，也可以自己命名，需要在define structure 的时候，比where多 了name和::</span><br><span class="line">  -- structure struc_name where constructor_name ::</span><br><span class="line">  --    ...</span><br><span class="line">-- open a namespace</span><br><span class="line">namespace namespace_name</span><br><span class="line">...</span><br><span class="line">end namespace_name</span><br></pre></td></tr></table></figure>
<h3 id="definations-and-theorems"><a href="#definations-and-theorems" class="headerlink" title="definations and theorems"></a>definations and theorems</h3><p>about namespace: when namespace not open, can use anonymous projection notation,which allows us to write <strong>a.add b</strong> instead of <strong>namespace_name.add a b</strong>.</p>
<p><strong>protected</strong> keyword</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- so that the theorem name is Point.add_comm,even when the namespace is open</span><br><span class="line">protected theorem add_comm (a b :Point) :add a b = add b a:=by</span><br><span class="line">  sorry</span><br></pre></td></tr></table></figure>
<h1 id="Lean-theorem"><a href="#Lean-theorem" class="headerlink" title="Lean theorem"></a>Lean theorem</h1><p>multiple arrows：隐式右结合（associate to the right）</p>
<h1 id="Lean使用快捷键"><a href="#Lean使用快捷键" class="headerlink" title="Lean使用快捷键"></a>Lean使用快捷键</h1><p>Ctrl-Shift-P ： get access to the Lean 4:show all abbreviations<br>Ctrl-Space : completion in the editior to guess the theorem name</p>
<h1 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h1><h2 id="运算的特殊写法"><a href="#运算的特殊写法" class="headerlink" title="运算的特殊写法"></a>运算的特殊写法</h2><ol>
<li>divisibility relation整除关系 |</li>
</ol>
<h2 id="提示写法"><a href="#提示写法" class="headerlink" title="提示写法"></a>提示写法</h2><p>“apply?”可以在右边得到suggestions</p>
<h2 id="重复证明过程的写法"><a href="#重复证明过程的写法" class="headerlink" title="重复证明过程的写法"></a>重复证明过程的写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--1. 使用hypothesis ：任意</span><br><span class="line">--2. 使用repeat</span><br><span class="line">example : min a b = min b a := by</span><br><span class="line">  have h : ∀ x y : ℝ, min x y ≤ min y x := by</span><br><span class="line">    intro x y</span><br><span class="line">    apply le_min</span><br><span class="line">    apply min_le_right</span><br><span class="line">    apply min_le_left</span><br><span class="line">  apply le_antisymm</span><br><span class="line">  apply h</span><br><span class="line">  apply h</span><br><span class="line">-----------------------</span><br><span class="line">example : min a b = min b a := by</span><br><span class="line">  apply le_antisymm</span><br><span class="line">  repeat</span><br><span class="line">    apply le_min</span><br><span class="line">    apply min_le_right</span><br><span class="line">    apply min_le_left</span><br></pre></td></tr></table></figure>
<h2 id="name-of-theorem"><a href="#name-of-theorem" class="headerlink" title="name_of_theorem"></a>name_of_theorem</h2><p>A_of_B_of_C: established something of the form A from hypothese of the form B and C,where A,B,C approximate the way we might read the goals out loud,e.g. x+y&lt;… probably start with add_lt.</p>
<h2 id="example-use-by-not-use-by"><a href="#example-use-by-not-use-by" class="headerlink" title="example use by &amp; not use by"></a>example use by &amp; not use by</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example (a b : R) : a - b = a + -b :=by</span><br><span class="line">  rw[sub_eq_add_neg a b]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">example (a b : R) : a - b = a + -b :=</span><br><span class="line">  sub_eq_add_neg a b</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="语法记录"><a href="#语法记录" class="headerlink" title="语法记录"></a>语法记录</h1><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line">section ... end</span><br><span class="line">-- 变量声明</span><br><span class="line">variable(v1 v2 v3 ... : type) </span><br><span class="line">-- 检查类型，或描述用法</span><br><span class="line">#check ...</span><br><span class="line">#check a -- a:R</span><br><span class="line">#check mul_comm -- mul_comm.&#123;u_1&#125; &#123;G : Type u_1&#125; [CommMagma G] (a b : G) : a * b = b * a</span><br><span class="line"></span><br><span class="line">#check norm_num -- 常量计算与比较，Normalize numerical expressions. Supports the operations + - * / ⁻¹ ^ and % over numerical types such as ℕ, ℤ, ℚ, ℝ, ℂ and some general algebraic types, and can prove goals of the form A = B, A ≠ B, A &lt; B and A ≤ B, where A and B are numerical expressions. It also has a relatively simple primality prover.</span><br><span class="line"></span><br><span class="line">-- Nat.gcd m n :最大公约数,在显示的时候会显示出来m.gcd.n</span><br></pre></td></tr></table></figure>

<h3 id="rfl-is-short-for-“reflexivity”"><a href="#rfl-is-short-for-“reflexivity”" class="headerlink" title="rfl is short for “reflexivity”."></a>rfl is short for “reflexivity”.</h3><h3 id="calc先定义阶段目标再填写过程"><a href="#calc先定义阶段目标再填写过程" class="headerlink" title="calc先定义阶段目标再填写过程"></a>calc先定义阶段目标再填写过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example:(a+b)*(a+b) = a*a+2*a*b +b*b:</span><br><span class="line">    calc</span><br><span class="line">        xx :by</span><br><span class="line">            xx</span><br><span class="line">        _=xxx:=by</span><br><span class="line">            xx</span><br><span class="line">        _=xxxx:=by</span><br><span class="line">            xxxx</span><br></pre></td></tr></table></figure>
<h3 id="have-先提出假设h进行证明，之后可以使用h推断goal"><a href="#have-先提出假设h进行证明，之后可以使用h推断goal" class="headerlink" title="have 先提出假设h进行证明，之后可以使用h推断goal"></a>have 先提出假设h进行证明，之后可以使用h推断goal</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theorem zero_mul(a: R):0*a  =0 := by</span><br><span class="line">    have h: 0*a+0*a = 0*a+0 :=by</span><br><span class="line">        rw[←add_mul,add_zero,add_zero]</span><br><span class="line">    rw[add_left_cancel h]</span><br></pre></td></tr></table></figure>
<h3 id="rw-…-…-…-替换"><a href="#rw-…-…-…-替换" class="headerlink" title="rw[…,…,…]替换"></a>rw[…,…,…]替换</h3><ol>
<li>变量</li>
</ol>
<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>左箭头表示a&#x3D;b:用a替换b</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nth_rw &lt;第几个&gt;[]替换</span><br><span class="line">rw[mul_assoc]--a*b*c = a*(b*c)</span><br><span class="line">rw[mul_assoc]--a*(b*c)=a*b*c</span><br><span class="line">sub_self -- a-a=0</span><br></pre></td></tr></table></figure>
<p>&lt;⬅&gt;mul_assoc <v><br>mul_comm &lt;v1,v2&gt;</p>
<h3 id="tactic：ring"><a href="#tactic：ring" class="headerlink" title="tactic：ring"></a>tactic：ring</h3><p>automation for that follow purely from the ring axioms</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example: c*b*a = b*(a*c):= by</span><br><span class="line">    ring</span><br></pre></td></tr></table></figure>
<p>a ring consists of a collection of<br>objects,<br>R,(R with + is an <strong>abelian group</strong>,with 0 as the additive identity , with negation as inverse)<br>operations + *,and (multiplication is associative with identity 1,and multiplication distributes over addition)<br>constants 0 and 1,and<br>an operation x-&gt;-x </p>
<p>Lean is good not only for proving things about concrete mathematical structures like the natural numbers and the integers, but also for proving things about abstract structures, characterized axiomatically, like rings. Moreover, Lean supports generic reasoning about both abstract and concrete structures, and can be trained to recognize appropriate instances.</p>
]]></content>
      <categories>
        <category>Lean</category>
      </categories>
      <tags>
        <tag>Lean</tag>
      </tags>
  </entry>
  <entry>
    <title>BugBlog</title>
    <url>/2024/12/11/BugBlog/</url>
    <content><![CDATA[<h1 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JAVA</span></span><br><span class="line"><span class="comment">// Wrong!!!,这样写改不了树，put不进去</span></span><br><span class="line"><span class="comment">//	public void NonrecursivePut(Key key,Value val)&#123;</span></span><br><span class="line"><span class="comment">//		if(key==null)throw new IllegalArgumentException(&quot;the 1st of Put() is null&quot;);</span></span><br><span class="line"><span class="comment">//		Node x = root;</span></span><br><span class="line"><span class="comment">//		while(x!=null)&#123;</span></span><br><span class="line"><span class="comment">//			int cmp = key.compareTo(x.key);</span></span><br><span class="line"><span class="comment">//			if(cmp&gt;0) x=x.right;</span></span><br><span class="line"><span class="comment">//			else if(cmp&lt;0) x= x.left;</span></span><br><span class="line"><span class="comment">//			else x.val=val;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		x=new Node(key,val);Wrong!!因为只是将临时引用指向了新创建的对象，而实际的x.left或x.right引用依然为null</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution: 记录父节点，通过修改父节点.left和right进行</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题</title>
    <url>/2024/10/05/hello-world/</url>
    <content><![CDATA[<h2 id="指路Next入门教程"><a href="#指路Next入门教程" class="headerlink" title="指路Next入门教程"></a><a href="https://hexo-next.readthedocs.io/zh-cn/latest/next/">指路Next入门教程</a></h2>]]></content>
      <categories>
        <category>Hexo-Next</category>
      </categories>
      <tags>
        <tag>Beautify</tag>
      </tags>
  </entry>
  <entry>
    <title>compiler impletment learn from Jack W. Crenshaw</title>
    <url>/2024/10/26/compiler-impletment-learn-from-Jack-W-Crenshaw/</url>
    <content><![CDATA[<p><a href="https://compilers.iecc.com/crenshaw">学习网站</a></p>
<h1 id="学习过程中的不懂问题"><a href="#学习过程中的不懂问题" class="headerlink" title="学习过程中的不懂问题"></a>学习过程中的不懂问题</h1><blockquote>
<p>使用栈计算表达式时，‘)’ had  different precedence levels,depending upon whether or not it was already on the stack,you had to give it one value before you put it on the stack, and another to decide when to take it off.(不明白为啥右括号有不同优先级，咋还能入栈)<br>difference between interpreter and compiler : the recognizing of procedure, in the interpreter the recognizing procedure end up being coded as FUNCTIONS that return numeric values to their callers.None of the parsing routines for our compiler did that（不明白解释器和编译器在procedure翻译上的不同）<br>assembler: 目的是生成object code,normally does that on a one-to-one basis(one object instruction per line of source code),but almost ebery assember also permits expression as arguments.In this case, the expression are always constant expressions, and so the assembler isn’t supposed to issue object code for them. Rather, it “interpreters” the expression and computes the corresponding constant result,which is what it actually emits as object code（此处说的汇编器对常量表达式的处理是“lazy”概念，exap: x &#x3D; x+3-2-1最后生成时是对 x&#x3D; x+0甚至是x&#x3D;x）</p>
</blockquote>
<h1 id="阶段1-Single-Num-expression"><a href="#阶段1-Single-Num-expression" class="headerlink" title="阶段1 Single Num expression"></a>阶段1 Single Num expression</h1><h2 id="只含”-“的二元表达式"><a href="#只含”-“的二元表达式" class="headerlink" title="只含”+-“的二元表达式"></a>只含”+-“的二元表达式</h2><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    expr::= term&lt;+-term&gt;</span></span><br><span class="line"><span class="comment">    term::=GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Expression</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term;<span class="comment">&#123;MOVE #GetNum,D0;&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;MOVE D0,D1&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: Add;<span class="comment">&#123;Match(&#x27;+&#x27;);Term;ADD D1,D0;结果存在D0&#125;</span></span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: Substract;<span class="comment">&#123;Match(&#x27;-&#x27;);Term;SUB D1,D0;NEG D0;结果存在D0&#125;</span></span><br><span class="line">    <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="多个操作数"><a href="#多个操作数" class="headerlink" title="多个操作数"></a>多个操作数</h2><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;循环解决,将数压栈解决寄存器有限&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Expression</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term;<span class="comment">&#123;MOVE #GetNum,D0;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>);<span class="comment">&#123;D1=D0;&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: Add;<span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract;<span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB -(SP),D0; NEG D0 ;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="增加”-“"><a href="#增加”-“" class="headerlink" title="增加”*&#x2F;“"></a>增加”*&#x2F;“</h2><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    优先级高，单位更小</span></span><br><span class="line"><span class="comment">    expr::= term &lt;+- term&gt;</span></span><br><span class="line"><span class="comment">    term::= factor &lt;*/ factor&gt;</span></span><br><span class="line"><span class="comment">    factor::= GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Expression</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;压栈&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="keyword">Add</span><span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB (SP)-,D0; NEG D0;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Term</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Factor<span class="punctuation">;</span><span class="comment">&#123;GetNum;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: Multiply<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;*&#x27;);Factor;MUL (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: Divide<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;乘除操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<h2 id="增加”-”"><a href="#增加”-”" class="headerlink" title="增加”()”"></a>增加”()”</h2><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">    factor ::= (expr) or GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Factor</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look =<span class="string">&#x27;(&#x27;</span> than <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE&#x27;</span>+#GetNum+<span class="string">&#x27;,D0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="增加”-作为正负号的数”"><a href="#增加”-作为正负号的数”" class="headerlink" title="增加”-+作为正负号的数”"></a>增加”-+作为正负号的数”</h2><p>增加0-</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    expr::=- or term&lt;+-term&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Expression</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;CLR D0&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;D0=0;&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        term<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;压栈&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="keyword">Add</span><span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB (SP)-,D0; NEG D0;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>


<h1 id="阶段2-Assignment（name-expression，多位数和标识符Token识别）"><a href="#阶段2-Assignment（name-expression，多位数和标识符Token识别）" class="headerlink" title="阶段2 Assignment（name &#x3D; expression，多位数和标识符Token识别）"></a>阶段2 Assignment（name &#x3D; expression，多位数和标识符Token识别）</h1><h2 id="增加-单个字母的标识符（以及无参的函数调用C语言格式）"><a href="#增加-单个字母的标识符（以及无参的函数调用C语言格式）" class="headerlink" title="增加 单个字母的标识符（以及无参的函数调用C语言格式）"></a>增加 单个字母的标识符（以及无参的函数调用C语言格式）</h2><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    factor ::= GetNum | (expre) | Ident</span></span><br><span class="line"><span class="comment">    Ident ::= GetName &lt;&#x27;(&#x27;&#x27;)&#x27;&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Factor</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look =<span class="string">&#x27;(&#x27;</span> than <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> IsAlpha(Look) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        Ident;<span class="comment">&#123;标识符识别&#125;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       EmitLn(<span class="string">&#x27;MOVE&#x27;</span>+#GetNum+<span class="string">&#x27;,D0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;----------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Ident</span>;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">Name</span>:Char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">Name</span> :=GetName;</span><br><span class="line">    <span class="keyword">if</span> Look = <span class="string">&#x27;(&#x27;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        EmitLn(<span class="string">&#x27;BSR &#x27;</span>+<span class="keyword">Name</span>);<span class="comment">&#123;调用函数&#125;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> EmitLn(<span class="string">&#x27;MOVE &#x27;</span>+<span class="keyword">Name</span>+<span class="string">&#x27;(PC),D0&#x27;</span>);<span class="comment">&#123;将操作数取出来放在D0&#125;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="增加赋值语句"><a href="#增加赋值语句" class="headerlink" title="增加赋值语句"></a>增加赋值语句</h2><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Assignment ::= GetName = expr</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Assignment</span>;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">Name</span>:char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">Name</span>:=GetName;</span><br><span class="line">    Match(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    Expression;</span><br><span class="line">    <span class="comment">&#123;赋值汇编&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;LEA &#x27;</span>+<span class="keyword">Name</span>+<span class="string">&#x27;(PC)&#x27;</span>,A0);<span class="comment">&#123;A0是地址寄存器，存放Name的地址，PC相对寻址&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;MOVE D0,(A0)&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="增加多位数和多个字母"><a href="#增加多位数和多个字母" class="headerlink" title="增加多位数和多个字母"></a>增加多位数和多个字母</h2><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    GetNum，GetName重写<span class="keyword">while</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> GetNum:<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">var</span> Value:<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Value:=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isDigit(Look) <span class="keyword">then</span> Expected(<span class="string">&#x27;Digit&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> isDigit(Look) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        Value:=Value+Look;</span><br><span class="line">        GetChar;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="增加空格过滤"><a href="#增加空格过滤" class="headerlink" title="增加空格过滤"></a>增加空格过滤</h2><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    识别空格，过滤空格，保证其余的识别开头第一个是非空格字符，即：</span><br><span class="line"></span><br><span class="line">    Init 中GetChar后要SkipWhite；</span><br><span class="line"></span><br><span class="line">    GetNum/Name 最后要SkipWhite;</span><br><span class="line">    </span><br><span class="line">    tips: LR (<span class="name">#10</span>,<span class="comment">^J</span>) CR($<span class="number">13</span>,<span class="comment">^M</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="阶段3：简单的interpreter"><a href="#阶段3：简单的interpreter" class="headerlink" title="阶段3：简单的interpreter"></a>阶段3：简单的interpreter</h1><p>interpreter就是等到必要时才打印，否则就一直计算</p>
<h2 id="识别表达式"><a href="#识别表达式" class="headerlink" title="识别表达式"></a>识别表达式</h2><figure class="highlight d"><table><tr><td class="code"><pre><span class="line">expr := -<span class="comment">/+ term &lt;+/</span>- term&gt;</span><br><span class="line">term := factor &lt;*/ factor&gt;</span><br><span class="line">factor := GetNum | (expr) </span><br></pre></td></tr></table></figure>
<h3 id="一位数字-即时计算"><a href="#一位数字-即时计算" class="headerlink" title="一位数字(即时计算)"></a>一位数字(即时计算)</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">-------------------------&#125;</span></span><br><span class="line">&#123;GetNum&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">GetNum:integer;</span></span><br><span class="line">begin</span><br><span class="line">    if not <span class="keyword">is</span>Digit(Look) <span class="keyword">then</span> Expected(<span class="symbol">&#x27;Integer</span>&#x27;);</span><br><span class="line">    GetNum := Ord(Look)-Ord(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    GetChar;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">----------------------------&#125;</span></span><br><span class="line">&#123;Factor&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Factor:integer;</span></span><br><span class="line">begin</span><br><span class="line">    if Look = &#x27;(&#x27; then</span><br><span class="line">    begin</span><br><span class="line">        Match(&#x27;(&#x27;);</span><br><span class="line">        Factor := Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> Factor := GetNum;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">-------------------------------&#125;</span></span><br><span class="line">&#123; Term &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Term:integer;</span></span><br><span class="line">var</span><br><span class="line">    Value :integer;</span><br><span class="line">begin</span><br><span class="line">    Value := Factor;</span><br><span class="line">    while <span class="keyword">is</span>Mulop(Look) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            Value:=Value * Factor;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            Value:=Value div Factor;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    Term := Value;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">-----------------------------&#125;</span></span><br><span class="line">&#123;Expression&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Expression:integer;</span></span><br><span class="line">var</span><br><span class="line">    Value:integer;</span><br><span class="line">begin</span><br><span class="line">    if <span class="keyword">is</span>Addop(Look) <span class="keyword">then</span> <span class="keyword">begin</span>&#123;能省略吗？不能因为省略后无法识别Term开头的表达式&#125;</span><br><span class="line">        Value:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> Value:= Term;</span><br><span class="line">    <span class="keyword">while</span> isAddop(Look) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            Value := Value +Term;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            Value := Value -Term;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    Expression := Value;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="多位数字-改动GetNum"><a href="#多位数字-改动GetNum" class="headerlink" title="多位数字(改动GetNum)"></a>多位数字(改动GetNum)</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">procadure GetChar;</span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">    <span class="title">Read</span><span class="params">(Look)</span></span>;</span><br><span class="line">end;</span><br><span class="line">function GetNum:integer;</span><br><span class="line">var</span><br><span class="line">    Value: integer;</span><br><span class="line">begin</span><br><span class="line">    Value :=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="keyword">not</span> <span class="title">isDigit</span><span class="params">(Look)</span> then <span class="title">Expected</span><span class="params">(<span class="string">&quot;Integer&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">isDigit</span><span class="params">(Look)</span> <span class="keyword">do</span></span></span><br><span class="line"><span class="function">    begin</span></span><br><span class="line"><span class="function">        Value :=</span> Value * <span class="number">10</span> +<span class="built_in">Ord</span>(Look)-<span class="built_in">Ord</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        GetChar;</span><br><span class="line">    end;</span><br><span class="line">    GetNum := Value;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h3 id="NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出"><a href="#NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出" class="headerlink" title="NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出"></a>NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出</h3><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    在我的电脑上windows的WSL上NewLine只用了LF</span></span><br><span class="line"><span class="comment">    结束符.</span></span><br><span class="line"><span class="comment">    输入符号表命令 ？Name Value</span></span><br><span class="line"><span class="comment">    输出符号表命令 ！Name </span></span><br><span class="line"><span class="comment">    对于WhiteSpace（在一个单元结束下一个单元开始前跳过中间的空格）：最小读取单元是数字或者单个字符，故在init的GetChar后添加skipWhite，在GetNum和GetName结束添加skipWhite（读到第一个非空格字符）,还需要在match后加上skipWhite</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123; 符号表 &#125;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">Table[<span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>] <span class="keyword">of</span> integer;</span><br><span class="line"><span class="comment">&#123; Input Table&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Input</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Match(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    <span class="keyword">Read</span>(Table[GetName]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">&#123;Output&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Output</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Match(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="keyword">Write</span>(Table[GetName]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">NewLine</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> isNewLine(Look) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            GetChar;</span><br><span class="line">            SkipWhite;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">&#123; Main &#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span> </span><br><span class="line">        <span class="string">&#x27;?&#x27;</span>: Input;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span>: Output;</span><br><span class="line">        <span class="keyword">else</span> Assignment;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        NewLine;</span><br><span class="line">        <span class="keyword">until</span> Look = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>turbo pascal</tag>
        <tag>68000 Assembly</tag>
        <tag>Jack W. Crenshaw</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>theorem_proving_in_lean4</title>
    <url>/2025/01/17/theorem-proving-in-lean4/</url>
    <content><![CDATA[<p><a href="https://lean-lang.org/theorem_proving_in_lean4">theorem_proving_in_lean4</a><br>自动定理证明侧重于“发现”方面。解析定理证明器、表定理证明器、快速可满足性求解器等提供了在命题和一阶逻辑中确定公式有效性的方法。其他系统为特定语言和领域提供搜索程序和决策程序，例如整数或实数上的线性或非线性表达式。诸如 SMT（“可满足性模理论”）之类的架构将领域通用搜索方法与领域特定程序相结合。计算机代数系统和专门的数学软件包提供了执行数学计算、建立数学界限或查找数学对象的方法。计算也可以被视为证明，这些系统也有助于建立数学主张。<br>自动推理系统追求强大和高效，通常以牺牲可靠性为代价。这样的系统可能存在错误，而且很难确保它们提供的结果是正确的。相比之下，交互式定理证明侧重于定理证明的“验证”方面，要求每个主张都得到适当公理基础的证明支持。这设定了一个非常高的标准：每个推理规则和计算的每个步骤都必须通过诉诸先前的定义和定理来证明，一直到基本公理和规则。事实上，大多数这样的系统都提供了完全详尽的“证明对象”，可以传达给其他系统并进行独立检查。构建这样的证明通常需要更多的用户输入和交互，但它允许您获得更深入和更复杂的证明。<br>精益定理证明器旨在通过将自动化工具和方法置于支持用户交互和构建完全指定的公理证明的框架中来弥补交互式和自动化定理证明之间的差距。目标是同时支持数学推理和复杂系统推理，并验证这两个领域的主张。<br>Lean 的底层逻辑具有计算解释，Lean 也可以被视为一种编程语言。更确切地说，它可以被视为一种具有精确语义的程序编写系统，以及对程序计算的功能进行推理的系统。Lean 还具有充当其自己的元编程语言的机制，这意味着您可以使用 Lean 本身实现自动化并扩展 Lean 的功能.</p>
<h1 id="Dependent-Type-Theory（类型理论：任何一个表达式都是一个类型）"><a href="#Dependent-Type-Theory（类型理论：任何一个表达式都是一个类型）" class="headerlink" title="Dependent Type Theory（类型理论：任何一个表达式都是一个类型）"></a>Dependent Type Theory（类型理论：任何一个表达式都是一个类型）</h1><p>依赖类型理论的重要特征 </p>
<ol>
<li>each term has computational behavior</li>
<li>each term supports a notion of nomalization</li>
<li>term 包含很多信息，可以从中推断出信息<br>Lean 是基于依赖类型理论Calculus of Constructions，with a countable hierarchy of non-cumulative universes and inductive types，有编译器(生成可执行二进制文件)和interactive interpreter</li>
</ol>
<h2 id="Simple-Type-Theory"><a href="#Simple-Type-Theory" class="headerlink" title="Simple Type Theory"></a>Simple Type Theory</h2><p>Lean natural number is a 任意精度的无符号整数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">    def 声明new constant symbols</span><br><span class="line">    #check,#eval 辅助性命令一般#开头</span><br><span class="line">    类型理论：a -&gt; b 表示从a到b的函数类型</span><br><span class="line">    描述f是关于x的函数 f x(e.g. Nat.succ 2)</span><br><span class="line">    arrows associate to the right （Nat -&gt; Nat -&gt; Nat 是等同于Nat -&gt; (Nat -&gt; Nat)）</span><br><span class="line">    函数的partially apply： Nat.add 3等同于Nat.add 3 n 返回了一个函数等待第二个参数n</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Type-as-objects"><a href="#Type-as-objects" class="headerlink" title="Type as objects"></a>Type as objects</h2><p>不理解类型理论，不知道def定义的意思<br>不理解操作在type universes上是多态polymorphic（感觉是多个类型参数结果是一个类型）的，例子List a，表示不论a在哪个类型中，List a都有意义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Lean的底层基础无限类型层次，Type 0是小范围的类型，Type 1是更大的类型，包含Type 0作为一个元素，以此类推</span><br><span class="line">#check Type     -- Type 1</span><br><span class="line">#check Type 1   -- Type 2</span><br><span class="line">-- Lean依赖类型理论扩展的方式</span><br><span class="line">    -- 1. 类型本身，它们的类型是Type</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">-- 定义polymorphic constants（使用universe或者在定义时提供universe parameters）</span><br><span class="line">universe u</span><br><span class="line">def F (\a : Type u) : Type u := Prod \a \a</span><br><span class="line">------------------------------------------</span><br><span class="line">def G.&#123;v&#125; (\a : Type v) :Type v:= Prod \a \a</span><br></pre></td></tr></table></figure>
<h2 id="Function-Abstraction-and-Evaluation"><a href="#Function-Abstraction-and-Evaluation" class="headerlink" title="Function Abstraction and Evaluation"></a>Function Abstraction and Evaluation</h2><p>creating a function from another expression is a process known as <strong>lambda abstraction</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- fun 也可以用 λ 代替</span><br><span class="line">#check (fun x =&gt; x+1) -- Nat -&gt; Nat,此处leave off type notation省略了类型注释</span><br><span class="line">/-  fun (x : type) =&gt; t 其中()可以省略</span><br><span class="line">    对于x：\a 变量，可以构造表达式t:\b</span><br><span class="line">    λ (x: \a) =&gt; t 表示函数from \a to \b 将x 映射到t</span><br><span class="line">    其中x 是bound variable，占位符，whose scope does not extend beyond the expression t</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p><strong>alpha equivalent</strong> : expression that are the same  up to renaming of bound variables are called alpha equivalent, and considered as “the same”.</p>
<p><strong>definitionally equal</strong>： two terms that reduce to the same value are called definitionally equal</p>
<h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def self_name (arg1 arg2 : arg_Type) (arg3 :arg_type) : return_Type := expression</span><br><span class="line">-- 虽然返回类型Lean可以推断，但最好还是显示指出</span><br><span class="line">def fun1 := fun x:Nat =&gt; x+x -- def 定义函数就是有名字的fun或λ</span><br><span class="line">def fun2 (x:Nat)  : Nat := x+x</span><br><span class="line">def fun21 (x:Nat)  := x+x</span><br><span class="line"></span><br><span class="line">def fun3 : Nat -&gt; Nat := fun x =&gt; x+x</span><br><span class="line">def fun3 (x: Nat): Nat -&gt; Nat := fun x =&gt; x+x --这个第一个x会提示没有用到</span><br><span class="line">def f := 1</span><br><span class="line"></span><br><span class="line">def compose (α β γ :Type) (f: α → β ) (g : γ → α ) (x: γ ):β := f (g x)</span><br><span class="line"></span><br><span class="line">#eval compose Nat Nat Nat fun1 fun3 f --4</span><br></pre></td></tr></table></figure>
<h2 id="Local-Definitions"><a href="#Local-Definitions" class="headerlink" title="Local Definitions"></a>Local Definitions</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ;或换行都可以</span><br><span class="line">def curiosity :=</span><br><span class="line">    let x := 1+2</span><br><span class="line">    let y := x+1;let z:=y+1</span><br><span class="line">    x+y+z</span><br><span class="line">#eval curiosity -- 12</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">    ((fun a =&gt; t2) t1) 与 (let a := t1;t2)不一样；前者a是对t1的缩写，后者是a是一个变量，是一个整体</span><br><span class="line"></span><br><span class="line">    #eval (fun a:Nat =&gt; a+a) 1+1 -- 3</span><br><span class="line">    #eval (fun a:Nat =&gt; a*a) 1+1 -- 2</span><br><span class="line">    #eval (fun a:Nat =&gt; a*a) (1+1) -- 4</span><br><span class="line">    #eval let a:=1+1;a*a --4</span><br><span class="line"></span><br><span class="line">    -- 迷惑？？？：bar0会 进行type check，但是bar不会进行！！！！</span><br><span class="line">    def bar0 := let a:=Nat; fun x:a =&gt;x+2</span><br><span class="line">    def bar := (fun a =&gt; fun x : a =&gt; x + 2) Nat</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Varibles-and-Sections"><a href="#Varibles-and-Sections" class="headerlink" title="Varibles and Sections"></a>Varibles and Sections</h2><p>section可以没有名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section outer</span><br><span class="line">variable (\a \b \g :Type)</span><br><span class="line">variable (x: \a) (y: \b) --作用域在section中，包括里面的section也起作用</span><br><span class="line">section</span><br><span class="line">variable (x: \b) </span><br><span class="line">-- 与外部相同的定义会覆盖外部</span><br><span class="line">end</span><br><span class="line">end outer</span><br></pre></td></tr></table></figure>
<h2 id="NameSpaces"><a href="#NameSpaces" class="headerlink" title="NameSpaces"></a>NameSpaces</h2><p>namespase 必须有名字，有且仅有一个匿名在root level</p>
<blockquote>
<p>namespaces organize data and sections declare variables for insertion in definitions;sections are also useful for delimiting限制 the scope of commands such as “set_option” and “open”；对于variable 和 open命令，随着namespace关闭也失效</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace foo</span><br><span class="line">    namespace bar</span><br><span class="line">    end bar</span><br><span class="line">end foo</span><br><span class="line"></span><br><span class="line">open foo --可以在当前使用非嵌套foo的短名</span><br><span class="line"></span><br><span class="line">namespace foo</span><br><span class="line">end foo</span><br></pre></td></tr></table></figure>
<h2 id="What-makes-dependent-type-dependent"><a href="#What-makes-dependent-type-dependent" class="headerlink" title="What makes dependent type dependent"></a>What makes dependent type dependent</h2><p>看不懂举的例子是什么意思？？？？？？？不明白传值的时候哪个对应哪个！！！<br>type can depend on parameters<br>dependent function type(dependent arrow type) : (a:\a)-&gt;\b 其中\b 的值依赖于a (e.g. (a:\a) -&gt; \b a)</p>
<p>Dependent products are also called sigma types, and you can also write them as Σ a : α, β a. You can use ⟨a, b⟩ or Sigma.mk a b to create a dependent pair. The ⟨ and ⟩ characters may be typed with \langle and \rangle or &lt; and &gt;, respectively.</p>
<h2 id="implicit-arguments"><a href="#implicit-arguments" class="headerlink" title="implicit arguments"></a>implicit arguments</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- sorry produces a proof of anything or provides an object of any data type at all,但是不能用来证明False,会报错</span><br><span class="line">-- _ 代表implicit argument，表示自动填充</span><br><span class="line">-- 可以从传入的某个参数确定一些类型参数，此时类型参数可以用_代替</span><br><span class="line"></span><br><span class="line">-- 也可以在定义时，用 &#123;&#125;将可以推断的参数括起来，在传入时就无需显示指明</span><br><span class="line"></span><br><span class="line">-- (e : T) to specify the type T of an expression e ,这样写告诉Lean的elaborator 在解决隐式参数时使用T作为e的Type</span><br><span class="line"></span><br><span class="line">--  @List  -- 描述相同的方法，不过所用的参数都变成了explicit</span><br><span class="line"></span><br><span class="line">-- Numerals are overloaded in Lean</span><br><span class="line">#check 2 -- Nat</span><br><span class="line">#check (2 : Int) -- Int</span><br></pre></td></tr></table></figure>
<p>Lean 的实例化隐式参数(instantiating implicit arguments)可以用来infer function types , predicates , proofs<br><strong>elaboration</strong> : the process of instantiating these “holes” or “placeholders”</p>
<h1 id="Propositions-and-Proofs"><a href="#Propositions-and-Proofs" class="headerlink" title="Propositions and Proofs"></a>Propositions and Proofs</h1><h2 id="Propositions-as-Types"><a href="#Propositions-as-Types" class="headerlink" title="Propositions as Types"></a>Propositions as Types</h2><p>proposition represents a sort of data type. if proposition p is true then the type associated with p  is inhabited.constructing <code>t : p</code> tell us p is indeed true.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Prop is Sort 0</span><br><span class="line">-- Type u is Sort (u+1)</span><br><span class="line">-- if p q: Prop, then p \r q :Prop</span><br><span class="line"></span><br><span class="line">-- if p : Prop , t1 t2:p 则 t1 t2是相等的</span><br><span class="line">-- (fun x =&gt; t) s and t[s/x] as definitionally equal这个后者直接写这样会报错，所以不理解</span><br></pre></td></tr></table></figure>
<h2 id="Working-with-Propositions-as-Types"><a href="#Working-with-Propositions-as-Types" class="headerlink" title="Working with Propositions as Types"></a>Working with Propositions as Types</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">    -- &#x27;theorem&#x27; command is really a version of &#x27;def&#x27; command 对于类型检查器没有任何区别 Lean tags proof as irreducible 不可归约？， which serves as a hint to the parser（elaborator）that is generally no need to unfold them when processing a file.为何不需要展开?</span><br><span class="line">    -- Lean 并行处理证明和进程，因为proof的 irrelevance，一个proof 的正确性无需另一个定理的细节</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">-- #print theorem_name -- show you the proof of a theorem</span><br><span class="line"></span><br><span class="line">-- 显示指明临时假设的类型 #show</span><br><span class="line">variable &#123;p : Prop&#125;</span><br><span class="line">variable &#123;q : Prop&#125;</span><br><span class="line">theorem t1 : p \r q \r p :=</span><br><span class="line">    fun hp : p =&gt;</span><br><span class="line">    fun hq : q =&gt;</span><br><span class="line">    show p from hp -- 原先只写 hp 就可以</span><br><span class="line"></span><br><span class="line">axiom hp : p -- 等价于声明 p is true, as witnessed by hp</span><br></pre></td></tr></table></figure>
<p>the <code>axiom</code> declaration postulates假设 the existence of an element of the given type and may compromise影响 logical consistency. </p>
<h2 id="Propositional-Logic"><a href="#Propositional-Logic" class="headerlink" title="Propositional Logic"></a>Propositional Logic</h2><p>The order of operations is as follows:<br>not &gt; and &gt; or &gt; \imp &gt; \iff其中\imp（\r）右结合<br>连接词的定义在库 Prelude.core中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- example command states a theorem without naming it or storing it in the permanent context,只是检查了term的类型</span><br><span class="line"></span><br><span class="line">--  Curry-Howard isomorphism同构：and 和 prod是一种同构</span><br><span class="line">-- 当相关类型是推纳类型且可以从context中推断出来，就可以使用Lean的匿名构造符号 \langle \rlangle 或者 \&lt; \&gt;</span><br><span class="line">#check (⟨hp, hq⟩ : p ∧ q)</span><br><span class="line"></span><br><span class="line">-- e.bar 是 Foo.bar.e 的缩写，不需要打开一个namespase</span><br><span class="line">variable (ls : List Nat)</span><br><span class="line">#check ls.length</span><br><span class="line">#check List.length ls </span><br><span class="line"></span><br><span class="line">-- for auto construction \&lt; \&gt;</span><br><span class="line">example (h : p \and q): q \and p \and q := \&lt; h.right, h \&gt;</span><br><span class="line">-- 或者 \&lt; h.right , \&lt; h.left, h.right\&gt;\&gt;</span><br><span class="line">-- 或者 And.intro h.right h -- h.left = And.left</span><br><span class="line">-- Or.elim (h :p \or q) (left :p \r c) (right :q \r c) :c简写 h.elim (left) (right)</span><br><span class="line"></span><br><span class="line">-- or 有两个构造器constructors，so 不能匿名构造，但仍然可以简写</span><br><span class="line">-- 什么是constructors？？？</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ex falso sequitur quodlibet False \r c从错误中能推出任意事实</span><br><span class="line">example (hp : p) (hnp : \neg p) : q := Flase.elim (hnp hp) -- absurd hp hnp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Introfucing-Auxilisry-Subgoals"><a href="#Introfucing-Auxilisry-Subgoals" class="headerlink" title="Introfucing Auxilisry Subgoals"></a>Introfucing Auxilisry Subgoals</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- have (h : p) := s;t 和 (fun (h : p) =&gt;t) s 是一样的；s是p的证明，t是(h:p)期望假设的证明</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">    suffices to show： resoning backwards from a goal</span><br><span class="line">-/</span><br><span class="line">    example (h : p∧ q) : q ∧ p :=</span><br><span class="line">  have hp : p := h.left</span><br><span class="line">  suffices hq:q from And.intro hq hp -- leave us with two goals,1 . by proving the original goal of q \and p with additional hypothesis hq : q, 2. have to show q</span><br><span class="line">  show q from And.right h</span><br></pre></td></tr></table></figure>
<h2 id="Classical-Logic"><a href="#Classical-Logic" class="headerlink" title="Classical Logic"></a>Classical Logic</h2><p>namespace Classical 中是典型逻辑，添加了excluded middle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open Classical</span><br><span class="line">variable (p : Prop)</span><br><span class="line">#check em p -- p ∨ ¬ p</span><br><span class="line"></span><br><span class="line">-- 反证法形式化</span><br><span class="line">#check byContradiction -- (\neg p -&gt; False) -&gt; p</span><br><span class="line">-- 通过案例</span><br><span class="line">#check byCases -- (p -&gt; q) (\neg p -&gt; q) -&gt; q</span><br></pre></td></tr></table></figure>
<h1 id="Quantifiers-And-Equality"><a href="#Quantifiers-And-Equality" class="headerlink" title="Quantifiers And Equality"></a>Quantifiers And Equality</h1><h2 id="The-Universal-Quantifier"><a href="#The-Universal-Quantifier" class="headerlink" title="The Universal Quantifier"></a>The Universal Quantifier</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- x : \a ,p x 表示 p that holds of x</span><br><span class="line">-- 任意 x : \a, p x </span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">introduction:</span><br><span class="line"></span><br><span class="line">Given a proof of p x, in a context where x : α is arbitrary, we obtain a proof ∀ x : α, p x.</span><br><span class="line"></span><br><span class="line">Given a term t of type β x, in a context where x : α is arbitrary, we have (fun x : α =&gt; t) : (x : α) → β x.</span><br><span class="line"></span><br><span class="line">elimination:</span><br><span class="line"></span><br><span class="line">Given a proof ∀ x : α, p x and any term t : α, we obtain a proof of p t.</span><br><span class="line"></span><br><span class="line">Given a term s : (x : α) → β x and any term t : α, we have s t : β t.</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p>the expressions which differ up to renaming of bound variables are considered to be equivalent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 可以都用x来表示</span><br><span class="line">example (α : Type)(p q : α → Prop): (∀ x : α , p x ∧ q x) → ∀ x : α , p x :=</span><br><span class="line">  fun (h :∀ x : α , p x ∧ q x) =&gt;</span><br><span class="line">  (fun (z : α ) =&gt;  -- 在此处重命名了变量</span><br><span class="line">  show p z from (h z).left)</span><br></pre></td></tr></table></figure>
<p>It is the typing rule for dependent arrow types, and the universal quantifier in particular, that distinguished Prop from other types.依赖箭头的类型是箭头两边的最大类型，如果箭头右边是 Sort 0类型，则依赖箭头类型就是Sort 0</p>
<blockquote>
<p>Suppose we have α : Sort i and β : Sort j, where the expression β may depend on a variable x : α. Then (x : α) → β is an element of Sort (imax i j), where imax i j is the maximum of i and j if j is not 0, and 0 otherwise.<br>Prop as the type of proposition rather than data,and it is what makes Prop <strong>impredicative</strong><br>类型的幂： Notice that if α is any type, we can form the type α → Prop of all predicates on α （the “power type of α”）</p>
</blockquote>
<h2 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a>Equality</h2><p>rfl is the notation for (Eq.refl _) 将显示参数变成了隐式参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example : 2+3 = 5 := rfl -- Eq.refl _</span><br><span class="line"></span><br><span class="line">-- Eq.subst h1 h2 &#123;motive : \a -&gt; Prop &#125;(h1 : a = b) (h2 :motive a): motive b可以用 h1 \t h2代替,Eq.subst 推断 \a -&gt; Prop 需要instanse of higher-order unification，但这个问题是不可决定的（为什么？），有时会失败，\t 更有效</span><br><span class="line"></span><br><span class="line">#check congrArg  --congrArg.&#123;u, v&#125; &#123;α : Sort u&#125; &#123;β : Sort v&#125; &#123;a₁ a₂ : α&#125; (f : α → β) (h : a₁ = a₂) : f a₁ = f a₂</span><br><span class="line">#check congrFun --congrFun.&#123;u, v&#125; &#123;α : Sort u&#125; &#123;β : α → Sort v&#125; &#123;f g : (x : α) → β x&#125; (h : f = g) (a : α) : f a = g a</span><br><span class="line">#check congr --congr.&#123;u, v&#125; &#123;α : Sort u&#125; &#123;β : Sort v&#125; &#123;f₁ f₂ : α → β&#125; &#123;a₁ a₂ : α&#125; (h₁ : f₁ = f₂) (h₂ : a₁ = a₂) : f₁ a₁ = f₂ a₂</span><br><span class="line"></span><br><span class="line">-- 乘法分配率</span><br><span class="line">    -- 左结合</span><br><span class="line">#check Nat.mul_add</span><br><span class="line">#check Nat.left_distrib -- a *(b+c) = a*b +a*c</span><br><span class="line">    -- 右结合 省略</span><br></pre></td></tr></table></figure>
<h2 id="Calculational-Proof"><a href="#Calculational-Proof" class="headerlink" title="Calculational Proof"></a>Calculational Proof</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">calc </span><br><span class="line">    &lt;expr&gt;_0 &#x27;op_1&#x27; &lt;expr&gt;_1 &#x27;:=&#x27; &lt;proof&gt;_1</span><br><span class="line">    --expr&lt;&gt;_0可以单独一行，下面用&#x27;_&#x27;</span><br><span class="line">    /-</span><br><span class="line">    &lt;expr&gt;_0 </span><br><span class="line">    &#x27;_&#x27;      &#x27;op_1&#x27; &lt;expr&gt;_1 &#x27;:=&#x27; &lt;proof&gt;_1</span><br><span class="line">    -/</span><br><span class="line">    &#x27;_&#x27;      &#x27;op_2&#x27; &lt;expr&gt;_2 &#x27;:=&#x27; &lt;proof&gt;_2</span><br><span class="line">    ...</span><br><span class="line">    &#x27;_&#x27;      &#x27;op_n&#x27; &lt;expr&gt;_n &#x27;:=&#x27; &lt;proof&gt;_n</span><br><span class="line">-- each &lt;proof&gt;_i is a proof for &lt;expr&gt;_&#123;i-1&#125; op_i &lt;expr&gt;_i</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/-</span><br><span class="line">`rw` tactics: 重写目标</span><br><span class="line"></span><br><span class="line">use a given equality (which can be a hypothesis, a theorem name, or a complex term) to &quot;rewrite&quot; the goal. If doing so reduces the goal to an identity `t = t` ,the tatic applies reflexivity to prove it</span><br><span class="line"></span><br><span class="line">`simp` tactics:更机智的重写目标,自动选择和重复的重写</span><br><span class="line"></span><br><span class="line">rewrites the goal by applying the given identities repeatedly, in any order, anywhere they are applicable in a term. it also uses other rules that have been previously declared to the system, and applies commutativity wisely to avoid looping. </span><br><span class="line">-/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Lean</category>
      </categories>
      <tags>
        <tag>Lean</tag>
      </tags>
  </entry>
</search>
