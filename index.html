<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/16l.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32l.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16l.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"anaccountalready.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Come to Play">
<meta property="og:type" content="website">
<meta property="og:title" content="HelloWorld">
<meta property="og:url" content="https://anaccountalready.github.io/index.html">
<meta property="og:site_name" content="HelloWorld">
<meta property="og:description" content="Come to Play">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://anaccountalready.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>HelloWorld</title>
  







<link rel="dns-prefetch" href="https://www.anaccountalready.cn">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">HelloWorld</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yu"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Yu</p>
  <div class="site-description" itemprop="description">Come to Play</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/anaccountalready" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anaccountalready" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ZMYhehe@outlook.com" title="E-Mail → mailto:ZMYhehe@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anaccountalready.github.io/2025/01/31/Liner-Algebra/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Yu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HelloWorld">
      <meta itemprop="description" content="Come to Play">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | HelloWorld">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/31/Liner-Algebra/" class="post-title-link" itemprop="url">Liner_Algebra</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-31 22:06:11" itemprop="dateCreated datePublished" datetime="2025-01-31T22:06:11+08:00">2025-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-03 01:11:19" itemprop="dateModified" datetime="2025-02-03T01:11:19+08:00">2025-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linear-Algebra/" itemprop="url" rel="index"><span itemprop="name">Linear Algebra</span></a>
        </span>
    </span>

  
    <span id="/2025/01/31/Liner-Algebra/" class="post-meta-item leancloud_visitors" data-flag-title="Liner_Algebra" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/01/31/Liner-Algebra/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/01/31/Liner-Algebra/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>397</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>空间中的有向箭头，<br>列表<br>计算： 向量相加，向量数乘<br>#<br>向量的线性组合： 向量的数乘之和 a * $\vec{v}$ + b * $\vec{w}$ (a b 是可以任意变化的，代表对向量的伸缩)<br>张成的空间：所有表示为给定定向量线性组合的向量集合e.g. 一个平面就是两个（任意维）线性无关向量张成的空间；三个三维线性无关向量张成的空间三维空间<br>Linearly dependent: 一组向量中至少有一个是多余的，没有对张成的空间做出任何贡献，当有多个向量移除一个向量不会减少张成的空间，就称它们线性相关（其中一个向量可以被其他所有向量的线性组合表示出来）<br>Libearly independent:一组向量都增加了张成的空间 the only solution to $a * \vec{v} + b * \vec{w} + c * \vec{u} &#x3D; \vec{0} $ is a &#x3D; b &#x3D; c &#x3D; 0</p>
<p>The basis of a vector space is a set of linearly independent vectors that span the full space.基就是张成该空间的线性无关向量的集合</p>
<h1 id="linear-transformation（变换后直线依旧是直线，原点固定，看作保持网格线平行并且等距分布）"><a href="#linear-transformation（变换后直线依旧是直线，原点固定，看作保持网格线平行并且等距分布）" class="headerlink" title="linear transformation（变换后直线依旧是直线，原点固定，看作保持网格线平行并且等距分布）"></a>linear transformation（变换后直线依旧是直线，原点固定，看作保持网格线平行并且等距分布）</h1><p>可以把矩阵的列看成变换后的基向量，把矩阵乘积看成线性组合</p>
<p>例子： 一个坐标系，改变坐标距离，就不是线性变换，因为对角线原来是直线，变换后不是直线了</p>
<h1 id="the-“determinant”-of-a-transformation"><a href="#the-“determinant”-of-a-transformation" class="headerlink" title="the “determinant” of a transformation"></a>the “determinant” of a transformation</h1><p>行列式：线性变换对面积产生改变的比例
 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anaccountalready.github.io/2025/01/17/theorem-proving-in-lean4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Yu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HelloWorld">
      <meta itemprop="description" content="Come to Play">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | HelloWorld">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/17/theorem-proving-in-lean4/" class="post-title-link" itemprop="url">theorem_proving_in_lean4</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-17 17:13:29" itemprop="dateCreated datePublished" datetime="2025-01-17T17:13:29+08:00">2025-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-03 00:50:24" itemprop="dateModified" datetime="2025-02-03T00:50:24+08:00">2025-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Lean/" itemprop="url" rel="index"><span itemprop="name">Lean</span></a>
        </span>
    </span>

  
    <span id="/2025/01/17/theorem-proving-in-lean4/" class="post-meta-item leancloud_visitors" data-flag-title="theorem_proving_in_lean4" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/01/17/theorem-proving-in-lean4/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/01/17/theorem-proving-in-lean4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://lean-lang.org/theorem_proving_in_lean4">theorem_proving_in_lean4</a><br>自动定理证明侧重于“发现”方面。解析定理证明器、表定理证明器、快速可满足性求解器等提供了在命题和一阶逻辑中确定公式有效性的方法。其他系统为特定语言和领域提供搜索程序和决策程序，例如整数或实数上的线性或非线性表达式。诸如 SMT（“可满足性模理论”）之类的架构将领域通用搜索方法与领域特定程序相结合。计算机代数系统和专门的数学软件包提供了执行数学计算、建立数学界限或查找数学对象的方法。计算也可以被视为证明，这些系统也有助于建立数学主张。<br>自动推理系统追求强大和高效，通常以牺牲可靠性为代价。这样的系统可能存在错误，而且很难确保它们提供的结果是正确的。相比之下，交互式定理证明侧重于定理证明的“验证”方面，要求每个主张都得到适当公理基础的证明支持。这设定了一个非常高的标准：每个推理规则和计算的每个步骤都必须通过诉诸先前的定义和定理来证明，一直到基本公理和规则。事实上，大多数这样的系统都提供了完全详尽的“证明对象”，可以传达给其他系统并进行独立检查。构建这样的证明通常需要更多的用户输入和交互，但它允许您获得更深入和更复杂的证明。<br>精益定理证明器旨在通过将自动化工具和方法置于支持用户交互和构建完全指定的公理证明的框架中来弥补交互式和自动化定理证明之间的差距。目标是同时支持数学推理和复杂系统推理，并验证这两个领域的主张。<br>Lean 的底层逻辑具有计算解释，Lean 也可以被视为一种编程语言。更确切地说，它可以被视为一种具有精确语义的程序编写系统，以及对程序计算的功能进行推理的系统。Lean 还具有充当其自己的元编程语言的机制，这意味着您可以使用 Lean 本身实现自动化并扩展 Lean 的功能.</p>
<h1 id="Dependent-Type-Theory（类型理论：任何一个表达式都是一个类型）"><a href="#Dependent-Type-Theory（类型理论：任何一个表达式都是一个类型）" class="headerlink" title="Dependent Type Theory（类型理论：任何一个表达式都是一个类型）"></a>Dependent Type Theory（类型理论：任何一个表达式都是一个类型）</h1><p>依赖类型理论的重要特征 </p>
<ol>
<li>each term has computational behavior</li>
<li>each term supports a notion of nomalization</li>
<li>term 包含很多信息，可以从中推断出信息<br>Lean 是基于依赖类型理论Calculus of Constructions，with a countable hierarchy of non-cumulative universes and inductive types，有编译器(生成可执行二进制文件)和interactive interpreter</li>
</ol>
<h2 id="Simple-Type-Theory"><a href="#Simple-Type-Theory" class="headerlink" title="Simple Type Theory"></a>Simple Type Theory</h2><p>Lean natural number is a 任意精度的无符号整数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line">    def 声明new constant symbols</span><br><span class="line">    #check,#eval 辅助性命令一般#开头</span><br><span class="line">    类型理论：a -&gt; b 表示从a到b的函数类型</span><br><span class="line">    描述f是关于x的函数 f x(e.g. Nat.succ 2)</span><br><span class="line">    arrows associate to the right （Nat -&gt; Nat -&gt; Nat 是等同于Nat -&gt; (Nat -&gt; Nat)）</span><br><span class="line">    函数的partially apply： Nat.add 3等同于Nat.add 3 n 返回了一个函数等待第二个参数n</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Type-as-objects"><a href="#Type-as-objects" class="headerlink" title="Type as objects"></a>Type as objects</h2><p>不理解类型理论，不知道def定义的意思<br>不理解操作在type universes上是多态polymorphic（感觉是多个类型参数结果是一个类型）的，例子List a，表示不论a在哪个类型中，List a都有意义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- Lean的底层基础无限类型层次，Type 0是小范围的类型，Type 1是更大的类型，包含Type 0作为一个元素，以此类推</span><br><span class="line">#check Type     -- Type 1</span><br><span class="line">#check Type 1   -- Type 2</span><br><span class="line">-- Lean依赖类型理论扩展的方式</span><br><span class="line">    -- 1. 类型本身，它们的类型是Type</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">-- 定义polymorphic constants（使用universe或者在定义时提供universe parameters）</span><br><span class="line">universe u</span><br><span class="line">def F (\a : Type u) : Type u := Prod \a \a</span><br><span class="line">------------------------------------------</span><br><span class="line">def G.&#123;v&#125; (\a : Type v) :Type v:= Prod \a \a</span><br></pre></td></tr></table></figure>
<h2 id="Function-Abstraction-and-Evaluation"><a href="#Function-Abstraction-and-Evaluation" class="headerlink" title="Function Abstraction and Evaluation"></a>Function Abstraction and Evaluation</h2><p>creating a function from another expression is a process known as <strong>lambda abstraction</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- fun 也可以用 λ 代替</span><br><span class="line">#check (fun x =&gt; x+1) -- Nat -&gt; Nat,此处leave off type notation省略了类型注释</span><br><span class="line">/-  fun (x : type) =&gt; t 其中()可以省略</span><br><span class="line">    对于x：\a 变量，可以构造表达式t:\b</span><br><span class="line">    λ (x: \a) =&gt; t 表示函数from \a to \b 将x 映射到t</span><br><span class="line">    其中x 是bound variable，占位符，whose scope does not extend beyond the expression t</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p><strong>alpha equivalent</strong> : expression that are the same  up to renaming of bound variables are called alpha equivalent, and considered as “the same”.</p>
<p><strong>definitionally equal</strong>： two terms that reduce to the same value are called definitionally equal</p>
<h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def self_name (arg1 arg2 : arg_Type) (arg3 :arg_type) : return_Type := expression</span><br><span class="line">-- 虽然返回类型Lean可以推断，但最好还是显示指出</span><br><span class="line">def fun1 := fun x:Nat =&gt; x+x -- def 定义函数就是有名字的fun或λ</span><br><span class="line">def fun2 (x:Nat)  : Nat := x+x</span><br><span class="line">def fun21 (x:Nat)  := x+x</span><br><span class="line"></span><br><span class="line">def fun3 : Nat -&gt; Nat := fun x =&gt; x+x</span><br><span class="line">def fun3 (x: Nat): Nat -&gt; Nat := fun x =&gt; x+x --这个第一个x会提示没有用到</span><br><span class="line">def f := 1</span><br><span class="line"></span><br><span class="line">def compose (α β γ :Type) (f: α → β ) (g : γ → α ) (x: γ ):β := f (g x)</span><br><span class="line"></span><br><span class="line">#eval compose Nat Nat Nat fun1 fun3 f --4</span><br></pre></td></tr></table></figure>
<h2 id="Local-Definitions"><a href="#Local-Definitions" class="headerlink" title="Local Definitions"></a>Local Definitions</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- ;或换行都可以</span><br><span class="line">def curiosity :=</span><br><span class="line">    let x := 1+2</span><br><span class="line">    let y := x+1;let z:=y+1</span><br><span class="line">    x+y+z</span><br><span class="line">#eval curiosity -- 12</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">    ((fun a =&gt; t2) t1) 与 (let a := t1;t2)不一样；前者a是对t1的缩写，后者是a是一个变量，是一个整体</span><br><span class="line"></span><br><span class="line">    #eval (fun a:Nat =&gt; a+a) 1+1 -- 3</span><br><span class="line">    #eval (fun a:Nat =&gt; a*a) 1+1 -- 2</span><br><span class="line">    #eval (fun a:Nat =&gt; a*a) (1+1) -- 4</span><br><span class="line">    #eval let a:=1+1;a*a --4</span><br><span class="line"></span><br><span class="line">    -- 迷惑？？？：bar0会 进行type check，但是bar不会进行！！！！</span><br><span class="line">    def bar0 := let a:=Nat; fun x:a =&gt;x+2</span><br><span class="line">    def bar := (fun a =&gt; fun x : a =&gt; x + 2) Nat</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Varibles-and-Sections"><a href="#Varibles-and-Sections" class="headerlink" title="Varibles and Sections"></a>Varibles and Sections</h2><p>section可以没有名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">section outer</span><br><span class="line">variable (\a \b \g :Type)</span><br><span class="line">variable (x: \a) (y: \b) --作用域在section中，包括里面的section也起作用</span><br><span class="line">section</span><br><span class="line">variable (x: \b) </span><br><span class="line">-- 与外部相同的定义会覆盖外部</span><br><span class="line">end</span><br><span class="line">end outer</span><br></pre></td></tr></table></figure>
<h2 id="NameSpaces"><a href="#NameSpaces" class="headerlink" title="NameSpaces"></a>NameSpaces</h2><p>namespase 必须有名字，有且仅有一个匿名在root level</p>
<blockquote>
<p>namespaces organize data and sections declare variables for insertion in definitions;sections are also useful for delimiting限制 the scope of commands such as “set_option” and “open”；对于variable 和 open命令，随着namespace关闭也失效</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace foo</span><br><span class="line">    namespace bar</span><br><span class="line">    end bar</span><br><span class="line">end foo</span><br><span class="line"></span><br><span class="line">open foo --可以在当前使用非嵌套foo的短名</span><br><span class="line"></span><br><span class="line">namespace foo</span><br><span class="line">end foo</span><br></pre></td></tr></table></figure>
<h2 id="What-makes-dependent-type-dependent"><a href="#What-makes-dependent-type-dependent" class="headerlink" title="What makes dependent type dependent"></a>What makes dependent type dependent</h2><p>看不懂举的例子是什么意思？？？？？？？不明白传值的时候哪个对应哪个！！！<br>type can depend on parameters<br>dependent function type(dependent arrow type) : (a:\a)-&gt;\b 其中\b 的值依赖于a (e.g. (a:\a) -&gt; \b a)</p>
<p>Dependent products are also called sigma types, and you can also write them as Σ a : α, β a. You can use ⟨a, b⟩ or Sigma.mk a b to create a dependent pair. The ⟨ and ⟩ characters may be typed with \langle and \rangle or &lt; and &gt;, respectively.</p>
<h2 id="implicit-arguments"><a href="#implicit-arguments" class="headerlink" title="implicit arguments"></a>implicit arguments</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- sorry produces a proof of anything or provides an object of any data type at all,但是不能用来证明False,会报错</span><br><span class="line">-- _  placeholder代表implicit argument，表示自动填充</span><br><span class="line">-- 可以从传入的某个参数确定一些类型参数，此时类型参数可以用_代替</span><br><span class="line"></span><br><span class="line">-- 也可以在定义时，用 &#123;&#125;将可以推断的参数括起来，在传入时就无需显示指明</span><br><span class="line"></span><br><span class="line">-- (e : T) to specify the type T of an expression e ,这样写告诉Lean的elaborator 在解决隐式参数时使用T作为e的Type</span><br><span class="line"></span><br><span class="line">--  @List  -- 描述相同的方法，不过所用的参数都变成了explicit</span><br><span class="line"></span><br><span class="line">-- Numerals are overloaded in Lean</span><br><span class="line">#check 2 -- Nat</span><br><span class="line">#check (2 : Int) -- Int</span><br></pre></td></tr></table></figure>
<p>Lean 的实例化隐式参数(instantiating implicit arguments)可以用来infer function types , predicates , proofs<br><strong>elaboration</strong> : the process of instantiating these “holes” or “placeholders”</p>
<h1 id="Propositions-and-Proofs"><a href="#Propositions-and-Proofs" class="headerlink" title="Propositions and Proofs"></a>Propositions and Proofs</h1><h2 id="Propositions-as-Types"><a href="#Propositions-as-Types" class="headerlink" title="Propositions as Types"></a>Propositions as Types</h2><p>proposition represents a sort of data type. if proposition p is true then the type associated with p  is inhabited.constructing <code>t : p</code> tell us p is indeed true.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- Prop is Sort 0</span><br><span class="line">-- Type u is Sort (u+1)</span><br><span class="line">-- if p q: Prop, then p \r q :Prop</span><br><span class="line"></span><br><span class="line">-- if p : Prop , t1 t2:p 则 t1 t2是相等的</span><br><span class="line">-- (fun x =&gt; t) s and t[s/x] as definitionally equal这个后者直接写这样会报错，所以不理解</span><br></pre></td></tr></table></figure>
<h2 id="Working-with-Propositions-as-Types"><a href="#Working-with-Propositions-as-Types" class="headerlink" title="Working with Propositions as Types"></a>Working with Propositions as Types</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line">    -- &#x27;theorem&#x27; command is really a version of &#x27;def&#x27; command 对于类型检查器没有任何区别 Lean tags proof as irreducible 不可归约？， which serves as a hint to the parser（elaborator）that is generally no need to unfold them when processing a file.为何不需要展开?</span><br><span class="line">    -- Lean 并行处理证明和进程，因为proof的 irrelevance，一个proof 的正确性无需另一个定理的细节</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">-- #print theorem_name -- show you the proof of a theorem</span><br><span class="line"></span><br><span class="line">-- 显示指明临时假设的类型 #show</span><br><span class="line">variable &#123;p : Prop&#125;</span><br><span class="line">variable &#123;q : Prop&#125;</span><br><span class="line">theorem t1 : p \r q \r p :=</span><br><span class="line">    fun hp : p =&gt;</span><br><span class="line">    fun hq : q =&gt;</span><br><span class="line">    show p from hp -- 原先只写 hp 就可以</span><br><span class="line"></span><br><span class="line">axiom hp : p -- 等价于声明 p is true, as witnessed by hp</span><br></pre></td></tr></table></figure>
<p>the <code>axiom</code> declaration postulates假设 the existence of an element of the given type and may compromise影响 logical consistency. </p>
<h2 id="Propositional-Logic"><a href="#Propositional-Logic" class="headerlink" title="Propositional Logic"></a>Propositional Logic</h2><p>The order of operations is as follows:<br>not &gt; and &gt; or &gt; \imp &gt; \iff其中\imp（\r）右结合<br>连接词的定义在库 Prelude.core中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- example command states a theorem without naming it or storing it in the permanent context,只是检查了term的类型</span><br><span class="line"></span><br><span class="line">--  Curry-Howard isomorphism同构：and 和 prod是一种同构</span><br><span class="line">-- 当相关类型是推纳类型且可以从context中推断出来，就可以使用Lean的匿名构造符号 \langle \rlangle 或者 \&lt; \&gt;</span><br><span class="line">#check (⟨hp, hq⟩ : p ∧ q)</span><br><span class="line"></span><br><span class="line">-- e.bar 是 Foo.bar.e 的缩写，不需要打开一个namespase</span><br><span class="line">variable (ls : List Nat)</span><br><span class="line">#check ls.length</span><br><span class="line">#check List.length ls </span><br><span class="line"></span><br><span class="line">-- for auto construction \&lt; \&gt;</span><br><span class="line">example (h : p \and q): q \and p \and q := \&lt; h.right, h \&gt;</span><br><span class="line">-- 或者 \&lt; h.right , \&lt; h.left, h.right\&gt;\&gt;</span><br><span class="line">-- 或者 And.intro h.right h -- h.left = And.left</span><br><span class="line">-- Or.elim (h :p \or q) (left :p \r c) (right :q \r c) :c简写 h.elim (left) (right)</span><br><span class="line"></span><br><span class="line">-- or 有两个构造器constructors，so 不能匿名构造，但仍然可以简写</span><br><span class="line">-- 什么是constructors？？？</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- ex falso sequitur quodlibet False \r c从错误中能推出任意事实</span><br><span class="line">example (hp : p) (hnp : \neg p) : q := Flase.elim (hnp hp) -- absurd hp hnp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Introfucing-Auxilisry-Subgoals"><a href="#Introfucing-Auxilisry-Subgoals" class="headerlink" title="Introfucing Auxilisry Subgoals"></a>Introfucing Auxilisry Subgoals</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- have (h : p) := s;t 和 (fun (h : p) =&gt;t) s 是一样的；s是p的证明，t是(h:p)期望假设的证明</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">    suffices to show： resoning backwards from a goal</span><br><span class="line">-/</span><br><span class="line">    example (h : p∧ q) : q ∧ p :=</span><br><span class="line">  have hp : p := h.left</span><br><span class="line">  suffices hq:q from And.intro hq hp -- leave us with two goals,1 . by proving the original goal of q \and p with additional hypothesis hq : q, 2. have to show q</span><br><span class="line">  show q from And.right h</span><br></pre></td></tr></table></figure>
<h2 id="Classical-Logic"><a href="#Classical-Logic" class="headerlink" title="Classical Logic"></a>Classical Logic</h2><p>namespace Classical 中是典型逻辑，添加了excluded middle</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">open Classical</span><br><span class="line">variable (p : Prop)</span><br><span class="line">#check em p -- p ∨ ¬ p</span><br><span class="line"></span><br><span class="line">-- 反证法形式化</span><br><span class="line">#check byContradiction -- (\neg p -&gt; False) -&gt; p</span><br><span class="line">-- 通过案例</span><br><span class="line">#check byCases -- (p -&gt; q) (\neg p -&gt; q) -&gt; q</span><br></pre></td></tr></table></figure>
<h1 id="Quantifiers-And-Equality"><a href="#Quantifiers-And-Equality" class="headerlink" title="Quantifiers And Equality"></a>Quantifiers And Equality</h1><h2 id="The-Universal-Quantifier"><a href="#The-Universal-Quantifier" class="headerlink" title="The Universal Quantifier"></a>The Universal Quantifier</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- x : \a ,p x 表示 p that holds of x</span><br><span class="line">-- 任意 x : \a, p x </span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">introduction:</span><br><span class="line"></span><br><span class="line">Given a proof of p x, in a context where x : α is arbitrary, we obtain a proof ∀ x : α, p x.</span><br><span class="line"></span><br><span class="line">Given a term t of type β x, in a context where x : α is arbitrary, we have (fun x : α =&gt; t) : (x : α) → β x.</span><br><span class="line"></span><br><span class="line">elimination:</span><br><span class="line"></span><br><span class="line">Given a proof ∀ x : α, p x and any term t : α, we obtain a proof of p t.</span><br><span class="line"></span><br><span class="line">Given a term s : (x : α) → β x and any term t : α, we have s t : β t.</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p>the expressions which differ up to renaming of bound variables are considered to be equivalent</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 可以都用x来表示</span><br><span class="line">example (α : Type)(p q : α → Prop): (∀ x : α , p x ∧ q x) → ∀ x : α , p x :=</span><br><span class="line">  fun (h :∀ x : α , p x ∧ q x) =&gt;</span><br><span class="line">  (fun (z : α ) =&gt;  -- 在此处重命名了变量</span><br><span class="line">  show p z from (h z).left)</span><br></pre></td></tr></table></figure>
<p>It is the typing rule for dependent arrow types, and the universal quantifier in particular, that distinguished Prop from other types.依赖箭头的类型是箭头两边的最大类型，如果箭头右边是 Sort 0类型，则依赖箭头类型就是Sort 0</p>
<blockquote>
<p>Suppose we have α : Sort i and β : Sort j, where the expression β may depend on a variable x : α. Then (x : α) → β is an element of Sort (imax i j), where imax i j is the maximum of i and j if j is not 0, and 0 otherwise.<br>Prop as the type of proposition rather than data,and it is what makes Prop <strong>impredicative</strong><br>类型的幂： Notice that if α is any type, we can form the type α → Prop of all predicates on α （the “power type of α”）</p>
</blockquote>
<h2 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a>Equality</h2><p>rfl is the notation for (Eq.refl _) 将显示参数变成了隐式参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example : 2+3 = 5 := rfl -- Eq.refl _</span><br><span class="line"></span><br><span class="line">-- Eq.subst h1 h2 &#123;motive : \a -&gt; Prop &#125;(h1 : a = b) (h2 :motive a): motive b可以用 h1 \t h2代替,Eq.subst 推断 \a -&gt; Prop 需要instanse of higher-order unification，但这个问题是不可决定的（为什么？），有时会失败，\t 更有效</span><br><span class="line"></span><br><span class="line">#check congrArg  --congrArg.&#123;u, v&#125; &#123;α : Sort u&#125; &#123;β : Sort v&#125; &#123;a₁ a₂ : α&#125; (f : α → β) (h : a₁ = a₂) : f a₁ = f a₂</span><br><span class="line">#check congrFun --congrFun.&#123;u, v&#125; &#123;α : Sort u&#125; &#123;β : α → Sort v&#125; &#123;f g : (x : α) → β x&#125; (h : f = g) (a : α) : f a = g a</span><br><span class="line">#check congr --congr.&#123;u, v&#125; &#123;α : Sort u&#125; &#123;β : Sort v&#125; &#123;f₁ f₂ : α → β&#125; &#123;a₁ a₂ : α&#125; (h₁ : f₁ = f₂) (h₂ : a₁ = a₂) : f₁ a₁ = f₂ a₂</span><br><span class="line"></span><br><span class="line">-- 乘法分配率</span><br><span class="line">    -- 左结合</span><br><span class="line">#check Nat.mul_add</span><br><span class="line">#check Nat.left_distrib -- a *(b+c) = a*b +a*c</span><br><span class="line">    -- 右结合 省略</span><br></pre></td></tr></table></figure>
<h2 id="Calculational-Proof"><a href="#Calculational-Proof" class="headerlink" title="Calculational Proof"></a>Calculational Proof</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line">calc </span><br><span class="line">    &lt;expr&gt;_0 &#x27;op_1&#x27; &lt;expr&gt;_1 &#x27;:=&#x27; &lt;proof&gt;_1</span><br><span class="line">    --expr&lt;&gt;_0可以单独一行，下面用&#x27;_&#x27;</span><br><span class="line">    /-</span><br><span class="line">    &lt;expr&gt;_0 </span><br><span class="line">    &#x27;_&#x27;      &#x27;op_1&#x27; &lt;expr&gt;_1 &#x27;:=&#x27; &lt;proof&gt;_1</span><br><span class="line">    -/</span><br><span class="line">    &#x27;_&#x27;      &#x27;op_2&#x27; &lt;expr&gt;_2 &#x27;:=&#x27; &lt;proof&gt;_2</span><br><span class="line">    ...</span><br><span class="line">    &#x27;_&#x27;      &#x27;op_n&#x27; &lt;expr&gt;_n &#x27;:=&#x27; &lt;proof&gt;_n</span><br><span class="line">-- each &lt;proof&gt;_i is a proof for &lt;expr&gt;_&#123;i-1&#125; op_i &lt;expr&gt;_i</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line">`rw` tactics: 重写目标</span><br><span class="line"></span><br><span class="line">use a given equality (which can be a hypothesis, a theorem name, or a complex term) to &quot;rewrite&quot; the goal. If doing so reduces the goal to an identity `t = t` ,the tatic applies reflexivity to prove it</span><br><span class="line"></span><br><span class="line">`simp` tactics:更机智的重写目标,自动选择和重复的重写</span><br><span class="line"></span><br><span class="line">rewrites the goal by applying the given identities repeatedly, in any order, anywhere they are applicable in a term. it also uses other rules that have been previously declared to the system, and applies commutativity wisely to avoid looping. </span><br><span class="line">-/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--`存在Exists.intro` : Existential introduction. If a : α and h : p a, then ⟨a, h⟩ is a proof that ∃ x : α, p x</span><br></pre></td></tr></table></figure>
<h2 id="The-Existential-Quantifier"><a href="#The-Existential-Quantifier" class="headerlink" title="The Existential Quantifier"></a>The Existential Quantifier</h2><blockquote>
<p>the library includes both an <code>introduction rule</code> and an <code>elimination rule</code><br>对于introduction rule : to prove Exists x : \a, p x, need suitable term <code>t</code> and a proof of <code>p t</code><br>只需要显示提供任意一个可取的值，以及该值下成立的假设即可，</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- set_option pp.explicit true 后使用#print 可以display implicit argument</span><br><span class="line">/-</span><br><span class="line">-- Exists.intro.&#123;u&#125; &#123;α : Sort u&#125; &#123;p : α → Prop&#125; (w : α) (h : p w) : Exists p</span><br><span class="line">-- implicit argument &#123;p : α → Prop&#125;意味着Lean能自动推出原命题，但是根据提供的值可以有很多假设：Lean use the context to infer which one is appropriate</span><br><span class="line">example : ∃ x : Nat, x &gt; 0 :=</span><br><span class="line">  have h : 1 &gt; 0 := Nat.zero_lt_succ 0</span><br><span class="line">    Exists.intro 1 h</span><br><span class="line">    -- ⟨1, h⟩</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line">-- Exists.elim.&#123;u&#125; &#123;α : Sort u&#125; &#123;p : α → Prop&#125; &#123;b : Prop&#125;(h₁ : ∃ x, p x) (h₂ : ∀ (a : α), p a → b) : b</span><br><span class="line">-/</span><br><span class="line">variable (α : Type) (p q : α → Prop)</span><br><span class="line"></span><br><span class="line">example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=</span><br><span class="line">  Exists.elim h</span><br><span class="line">    (fun w =&gt;</span><br><span class="line">     fun hw : p w ∧ q w =&gt;</span><br><span class="line">     show ∃ x, q x ∧ p x from ⟨w, hw.right, hw.left⟩)</span><br><span class="line">/-`match .\a -&gt; prop.. with | ...` :拆分组件(组件自命名，可拆的数目多种多样自助)</span><br><span class="line">    the `match` statement destructs the exstential assertion into the components `w` and `hw`, which can be then used in the body of the statement to prove the proposition.</span><br><span class="line">-/</span><br><span class="line">variable (α : Type) (p q : α → Prop)</span><br><span class="line"></span><br><span class="line">example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=</span><br><span class="line">  match h with</span><br><span class="line">  | ⟨w, hw⟩ =&gt; ⟨w, hw.right, hw.left⟩</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">variable (α : Type) (p q : α → Prop)</span><br><span class="line">example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=</span><br><span class="line">  match h with</span><br><span class="line">  | ⟨w, hpw, hqw⟩ =&gt; ⟨w, hqw, hpw⟩</span><br><span class="line">  -- | ...=&gt; ...</span><br><span class="line">/- `let` : pattern-matching ,similar to `match h with | &lt;&gt; =&gt; &lt;&gt;`-/</span><br><span class="line">example &#123;α : Type&#125;&#123;p q : α → Prop&#125; (h : ∃ x ,p x ∧ q x ): ∃ x , q x ∧ p x:=</span><br><span class="line">  let ⟨ w, hpw, hqw⟩:= h</span><br><span class="line">  ⟨ w,hqw,hpw⟩</span><br></pre></td></tr></table></figure>
<h2 id="更多证明语言"><a href="#更多证明语言" class="headerlink" title="更多证明语言"></a>更多证明语言</h2><p><code>this</code> 代表上一个have匿名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">variable (f : Nat → Nat)</span><br><span class="line">variable (h : ∀ x : Nat, f x ≤ f (x + 1))</span><br><span class="line">example : f 0 ≤ f 3 :=</span><br><span class="line">  have : f 0 ≤ f 1 := h 0</span><br><span class="line">  have : f 0 ≤ f 2 := Nat.le_trans this (h 1) -- this : f 0 ≤ f 1</span><br><span class="line">  show f 0 ≤ f 3 from Nat.le_trans (by assumption) (h 2) -- (by assumption)如果目标可以inferred，就用assumption代</span><br><span class="line">  </span><br><span class="line">  -- by assumption的替代品那你，显示指出goal，notation &quot;‹&quot; p &quot;›&quot; =&gt; show p by assumption --`\f&lt; \f&gt;`</span><br><span class="line"></span><br><span class="line">example : f 0 ≥ f 1 → f 1 ≥ f 2 → f 0 = f 2 :=</span><br><span class="line">   fun p :(f 0 ≥ f 1) =&gt;</span><br><span class="line">    fun _ :(f 1 ≥ f 2) =&gt; -- 这个placeholder</span><br><span class="line">    have :  f 0 ≥ f 2 :=</span><br><span class="line">      Nat.le_trans ‹f 1 ≥ f 2 › ‹f 0 ≥ f 1 ›</span><br><span class="line">    have :f 0 ≤ f 2 :=</span><br><span class="line">      Nat.le_trans (h 0 ) (h 1)</span><br><span class="line"></span><br><span class="line">    Nat.le_antisymm this ‹f 0 ≥ f 2 ›  </span><br></pre></td></tr></table></figure>
<h1 id="Tactics"><a href="#Tactics" class="headerlink" title="Tactics"></a>Tactics</h1><p>by tactics</p>
<h2 id="Entering-Tactic-Mode"><a href="#Entering-Tactic-Mode" class="headerlink" title="Entering Tactic Mode"></a>Entering Tactic Mode</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line">`exact` is a variant of `apply` ,which signals that the expression given should fill the goal exactly.</span><br><span class="line"></span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p>tatics 可能会产生多个子目标，并且tag them,可以在窗口中看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- In the case of `apply` tactic, the tags are inferred from the parameters&#x27; names used in the And.intro declaration. </span><br><span class="line"></span><br><span class="line">-- can structure your tatics using the notation `case &lt;tag&gt; =&gt; &lt;tatics&gt;`,我认为这样可以改变解决默认的解决顺序</span><br><span class="line">    -- 也可以\. 结构化证明过程</span><br><span class="line">-- And.intro &#123;a b : Prop&#125; (left : a) (right : b) : a ∧ b</span><br><span class="line">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by</span><br><span class="line">  apply And.intro</span><br><span class="line">  case right =&gt;</span><br><span class="line">    apply And.intro</span><br><span class="line">    case left =&gt; exact hq</span><br><span class="line">    case right =&gt; exact hp</span><br><span class="line">  case left =&gt; exact hp</span><br></pre></td></tr></table></figure>
<h2 id="Basic-Tactics"><a href="#Basic-Tactics" class="headerlink" title="Basic Tactics"></a>Basic Tactics</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line">tactic `intro` : introduces a hypothesis, a variable of any type, is a command for constructing function abstraction interactively  (i.e., terms of the form fun x =&gt; e) 也可以像`match`一样提供多个参数,也可已使用`intros`</span><br><span class="line">intro </span><br><span class="line">| \&lt;\&gt; =&gt; ...</span><br><span class="line">| \&lt;\&gt; =&gt; ...</span><br><span class="line"></span><br><span class="line">也可以不提供任何参数：in which case, it chooses names and introduces as many variables as it can.结果是Lean自动生成名字(不能访问)，可以通过  use the combinator `unhygienic` to disable this restriction.</span><br><span class="line"></span><br><span class="line">-/</span><br><span class="line">example : ∀ a b c : Nat, a = b → a = c → c = b := by</span><br><span class="line">  intros -- 相当于跟着a✝² b✝ c✝ a✝¹ a✝ </span><br><span class="line">  rename_i a b c h1 h2</span><br><span class="line">  apply Eq.trans</span><br><span class="line">  apply Eq.symm</span><br><span class="line">  assumption</span><br><span class="line">  assumption</span><br><span class="line"></span><br><span class="line">example : ∀ a b c : Nat, a = b → a = c → c = b := by unhygienic</span><br><span class="line">  intros -- 相当于跟着 a b c a_1 a_2</span><br><span class="line">  apply Eq.trans</span><br><span class="line">  apply Eq.symm</span><br><span class="line">  exact a_2</span><br><span class="line">  exact a_1</span><br><span class="line">/-</span><br><span class="line">tactic `rename_i `:`rename_i x_1 ... x_n` :</span><br><span class="line">renames the last n inaccessible names using the given names.</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">tactic `assumption` : </span><br><span class="line">looks through the assumptions in context of the current goal, and if there is one matching the conclusion, it applies it.</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">The `rfl` tactic is syntactic sugar for `exact rfl`</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">The `revert` tactic is an reverse to `intro`, 把假设转为目标</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/-`generalize` tactic replace an arbitrary expression in the goal by a fresh variable: 将目标中的任意表达式替换成新变量 `generalize [h :]expre = variable`,但替换可能会导致goal不可证明-/</span><br><span class="line">example : 2 + 3 = 5 :=by</span><br><span class="line">  generalize h : 3 = x -- goal: 2 + x = 5</span><br><span class="line">  rw[← h] -- 2 +3 = 5已经证明完毕了</span><br><span class="line"></span><br><span class="line">/-`admit` :tactic</span><br><span class="line"> is the analogue相似 of the `sorry` tactics-/</span><br><span class="line"></span><br><span class="line">/-`cases` : </span><br><span class="line">decompose any element of an inductively defined type,子目标解决顺序任意；对于子目标使用相同策略的证明有用，和`match`的语法类似 cases h with ,我认为区别在于match需要用函数构造，而cases直接使用tag作为函数名了-/</span><br><span class="line">| &lt;tag1&gt; =&gt; &lt;tactics1&gt; -- tag是Lean在声明中的参数名</span><br><span class="line">| &lt;tag2&gt; =&gt; &lt;tactics2&gt;</span><br><span class="line">-/</span><br><span class="line">  -- cases h with</span><br><span class="line">  -- | inl hp =&gt; apply Or.inr hp -- inl是tag，hp是参数（根据此情况需要传入的参数）</span><br><span class="line">  -- | inr hq =&gt; apply Or.inl; exact hq</span><br><span class="line">example (p q : Prop) : p ∧ q → q ∧ p := by</span><br><span class="line">  intros h</span><br><span class="line">  cases h with</span><br><span class="line">  | intro left right =&gt; apply And.intro right left</span><br><span class="line"></span><br><span class="line">example (p q : Prop) : p ∧ q → q ∧ p := by</span><br><span class="line">  intros h</span><br><span class="line">  match h with</span><br><span class="line">  | And.intro left right =&gt; apply And.intro right left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 使用相同策略</span><br><span class="line">example (p : Prop): p ∨ p → p := by</span><br><span class="line">  intro h</span><br><span class="line">  cases h</span><br><span class="line">  repeat assumption</span><br><span class="line"></span><br><span class="line">/-combinator `tac1 &lt;;&gt; tac2` ： </span><br><span class="line">&lt;;&gt; operator provides a parallel version of the sequencing operation: tac1 is applied to the current goal, and then apply the tactic `tac2` to each subgoal produced by tactic `tac1`</span><br><span class="line">-/</span><br><span class="line">example (p : Prop) : p ∨ p → p := by</span><br><span class="line">  intro h</span><br><span class="line">  cases h &lt;;&gt; assumption</span><br><span class="line"></span><br><span class="line">/-`constructor`: apply the first applicable constructor of an inductively defined type</span><br><span class="line"></span><br><span class="line">-/</span><br><span class="line">example (p q : Prop) : p ∧ q → q ∧ p := by</span><br><span class="line">  intros h</span><br><span class="line">  match h with</span><br><span class="line">  | And.intro left right =&gt; constructor; exact right; exact left -- constructor</span><br><span class="line">example (p q : Prop) : p ∧ q → q ∧ p := by</span><br><span class="line">  intros h</span><br><span class="line">  match h with</span><br><span class="line">  | And.intro left right =&gt; constructor&lt;;&gt; assumption -- tac1 &lt;;&gt; tac2</span><br><span class="line"></span><br><span class="line">-- case and constructor</span><br><span class="line">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by</span><br><span class="line">  intros h</span><br><span class="line">  cases h with</span><br><span class="line">  | intro w hpw =&gt; constructor ; apply Or.inl; exact hpw</span><br><span class="line"></span><br><span class="line">/-`contradiction`:</span><br><span class="line">contradiction closes the main goal if its hypotheses are &quot;trivially contradictory&quot;.</span><br><span class="line">example (h : False) : q := by</span><br><span class="line">  contradiction</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">-- “combine” `intro h` with `match h ...`</span><br><span class="line">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by</span><br><span class="line">  apply Iff.intro</span><br><span class="line">  . intro h</span><br><span class="line">    match h with</span><br><span class="line">    -- 可以推断出来</span><br><span class="line">    | And.intro _ (Or.inl _) =&gt; apply Or.inl (⟨by assumption ,by assumption⟩ ) -- 自动推断 by assumption</span><br><span class="line">    | And.intro hp (Or.inr hr) =&gt; apply Or.inr (⟨hp ,hr⟩ )</span><br><span class="line">  . intro -- intro 和match 合二为一了</span><br><span class="line">    | Or.inl ⟨hp, hq⟩ =&gt; constructor; exact hp; apply Or.inl; exact hq</span><br><span class="line">    | Or.inr ⟨hp, hr⟩ =&gt; constructor; exact hp; apply Or.inr; exact hr</span><br></pre></td></tr></table></figure>
<h2 id="Structuring-Tactic-Proofs"><a href="#Structuring-Tactic-Proofs" class="headerlink" title="Structuring Tactic Proofs"></a>Structuring Tactic Proofs</h2><p><code>apply</code> and  <code>exact</code> 可以传入任意term,e.g. (using <code>have</code> <code>show</code>这两个属于 term-style的term…) can invoke tactic mode by inserting a <code>by</code> block,也有<code>show</code> 的tactic</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := </span><br><span class="line">  by intro h</span><br><span class="line">  by exact</span><br><span class="line">    have hp : p := h.left</span><br><span class="line">    have hqr : q ∨ r := h.right</span><br><span class="line">    show (p ∧ q) ∨ (p ∧ r) by -- 此处是show .. by 是term-style</span><br><span class="line">      cases hqr with</span><br><span class="line">      | inl hq =&gt; exact Or.inl ⟨hp, hq⟩</span><br><span class="line">      | inr hr =&gt; exact Or.inr ⟨hp, hr⟩</span><br><span class="line"></span><br><span class="line">/-`show` tactic:</span><br><span class="line">declares the type of the goal that is about to be solved,while remaining in tactic mode</span><br><span class="line">`show t` finds the first goal whose target unifies with t. It makes that the main goal, performs the unification, and replaces the target with the unified version of t.重写目标为定义上相等的东西</span><br><span class="line">-/</span><br><span class="line">example (n : Nat) : n + 1 = Nat.succ n := by</span><br><span class="line">  show Nat.succ n = Nat.succ n</span><br><span class="line">  rfl</span><br><span class="line"></span><br><span class="line">/-`have` tactic:</span><br><span class="line">intoduces a new subgoal,</span><br><span class="line">have name_label : xxx := ... </span><br><span class="line">1. can omit the label in the `have` tactic, in which case, the default label `this` is used</span><br><span class="line">2. can omit types in the `have` tactic </span><br><span class="line">-/ </span><br><span class="line">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by</span><br><span class="line">  intro ⟨hp, hqr⟩</span><br><span class="line">  show (p ∧ q) ∨ (p ∧ r)</span><br><span class="line">  cases hqr with</span><br><span class="line">  | inl hq =&gt;</span><br><span class="line">    have hpq: p ∧ q := And.intro hp hq-- 定义label</span><br><span class="line">    apply Or.inl</span><br><span class="line">    exact hpq</span><br><span class="line">  | inr hr =&gt;</span><br><span class="line">    have : p ∧ r := And.intro hp hr -- 省略label</span><br><span class="line">    apply Or.inr</span><br><span class="line">    exact this</span><br><span class="line"></span><br><span class="line">/-`let` tactic:</span><br><span class="line">introduce local definitions</span><br><span class="line">the difference between `let` and `have` is that `let` introduces a local definition in the contextt, so that the definition of the local declaration can be unfolded in the proof.</span><br><span class="line">-- let a : Nat := 3 * 2 -- 类型可以省略</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">/- notation`.` : </span><br><span class="line">空格敏感，依赖于对齐来检测whether the tactic block ends.</span><br><span class="line"></span><br><span class="line">不用`.` 也可以使用&#123;&#125; 和 ; 来确定block</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<p>看起来有结构的方式: <code>.</code> <code>case label =&gt;</code> <code>&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line">apply foo</span><br><span class="line">  . &lt;proof of first goal&gt;</span><br><span class="line">  . &lt;proof of second goal&gt;</span><br><span class="line">  </span><br><span class="line">  case &lt;tag of first goal&gt;  =&gt; &lt;proof of first goal&gt;</span><br><span class="line">  case &lt;tag of second goal&gt; =&gt; &lt;proof of second goal&gt;</span><br><span class="line"> </span><br><span class="line">  &#123; &lt;proof of first goal&gt;  &#125;</span><br><span class="line">  &#123; &lt;proof of second goal&gt; &#125;</span><br><span class="line">  </span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Tactic-Combinators-are-operations-that-form-new-tactics-from-old-ones"><a href="#Tactic-Combinators-are-operations-that-form-new-tactics-from-old-ones" class="headerlink" title="Tactic Combinators( are operations that form new tactics from old ones)"></a>Tactic Combinators( are operations that form new tactics from old ones)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line">The `first | t₁ | t₂ | ... | tₙ` applies each `tᵢ` until one succeeds, or else fails</span><br><span class="line"></span><br><span class="line">`skip` tactic does nothing and succeeds</span><br><span class="line"></span><br><span class="line">-/</span><br><span class="line">example (p q : Prop) (hp : p) : p ∨ q := by</span><br><span class="line">  first | apply Or.inl; assumption | apply Or.inr; assumption</span><br><span class="line"></span><br><span class="line">example (p q : Prop) (hq : q) : p ∨ q := by</span><br><span class="line">  first | apply Or.inl; assumption | apply Or.inr; assumption</span><br><span class="line"></span><br><span class="line">/-</span><br><span class="line">`try` tac runs tac and succeeds even if tac failed.</span><br><span class="line">!! `repeat (try tac)` will loop forver,because `try tac` will always succeed</span><br><span class="line">-/</span><br><span class="line">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by</span><br><span class="line">  -- 第一个constructor 将goal 变为 case left : p 和 case right : q ∧ r</span><br><span class="line">  -- 第二个constructor只在case right 才会执行</span><br><span class="line">  constructor &lt;;&gt; (try constructor) &lt;;&gt; assumption</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">/-`all_goals tac` : </span><br><span class="line">applies tac to all open goals</span><br><span class="line">-/</span><br><span class="line">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by</span><br><span class="line">  constructor</span><br><span class="line">  all_goals (try constructor)</span><br><span class="line">  all_goals assumption</span><br><span class="line"></span><br><span class="line">/-`any_goals tac`:</span><br><span class="line">与`all_goal`类似，except it succeeds if its argument succeed on at least one goal</span><br><span class="line"> -/</span><br><span class="line">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by</span><br><span class="line">  repeat any_goals constructor</span><br><span class="line">  all_goals assumption</span><br><span class="line">  -- repeat (first | constructor | assumption )</span><br><span class="line"></span><br><span class="line">/-`focus t `combinator ensures that `t` only effects the current goal,temporarily hiding the others from the scope.So, if t ordinarily only effects the current goal, focus (all_goals t) has the same effect as t. </span><br><span class="line">-/</span><br><span class="line">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by</span><br><span class="line">  constructor</span><br><span class="line">  case right =&gt; constructor ; all_goals assumption</span><br><span class="line">  case left =&gt; focus (all_goals apply hp) -- 等价于 focus (apply hp)</span><br></pre></td></tr></table></figure>
<h2 id="Rewriting"><a href="#Rewriting" class="headerlink" title="Rewriting"></a>Rewriting</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/-`rewrite [t]`: t is a term whose type asserts an equality.</span><br><span class="line">1. 有多个可以替换时默认选择第一个进行替换</span><br><span class="line">2. noatation `rw [t] at h` : 在h中rw</span><br><span class="line">-/</span><br></pre></td></tr></table></figure>
<h2 id="Using-the-Simplifier"><a href="#Using-the-Simplifier" class="headerlink" title="Using the Simplifier"></a>Using the Simplifier</h2><p>A number of identities in Lean’s library have been tagged with the [simp] attribute, and the <code>simp</code> tactic uses them to iteratively rewrite subterms in an expression.也可以使用<code>at h</code>指定在h中应用<br>simp 对于交换和结合顺序的解释:the simplifier uses these two facts to rewrite an expression, as well as left commutativity. 对于local modifier告诉simplifier使用右结合， It may seem that commutativity and left-commutativity are problematic, in that repeated application of either causes looping。But the simplifier detects identities that permute their arguments, and uses a technique known as ordered rewriting.<br>也许是最后的goal会变成右结合，但simp会报错made no progress</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 例子</span><br><span class="line">example (w x y z : Nat) (p : Nat → Prop)</span><br><span class="line">        : x * y + (z * w) * x = x * w * z + y * x := by</span><br><span class="line">  simp</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/-`simp`</span><br><span class="line">1. do propositional rewriting. using hypothesis p, it rewrites p ∧ q to q and p ∨ q to true</span><br><span class="line">2. 对于新的定义，也可以使用simp，可以在定义时标注 @[simp] （表示定理具有 [simp] 属性； 第二种方式是拉出来写 `attribute [simp] theorem_name`）就可以在使用`simp`时不显式指明定理</span><br><span class="line">-/</span><br><span class="line"></span><br><span class="line">example (p q : Prop) (hp : p) : p ∧ q ↔ q := by</span><br><span class="line">  simp [*] -- 重写：p ∧ q = q</span><br><span class="line">example (x y z : Nat) : (x + 0) * (0 + y * 1 + z * 0) = x * y := by</span><br><span class="line">  simp -- 使用了带有simp属性的等式</span><br><span class="line"></span><br><span class="line">example (x y z : Nat) (p : Nat → Prop) (h : p (x * y))</span><br><span class="line">        : p ((x + 0) * (0 + y * 1 + z * 0)) := by</span><br><span class="line">  simp at *; assumption</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def mk_symm (xs : List α) :=</span><br><span class="line"> xs ++ xs.reverse</span><br><span class="line">theorem reverse_mk_symm (xs : List α)</span><br><span class="line">        : (mk_symm xs).reverse = mk_symm xs := by</span><br><span class="line">  simp [mk_symm]</span><br><span class="line"></span><br><span class="line">example (xs ys : List Nat)</span><br><span class="line">        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by</span><br><span class="line">  simp [reverse_mk_symm]</span><br><span class="line"></span><br><span class="line">attribute [simp] reverse_mk_symm -- 这个属性一直存在(只要导入了含有属性声明的文件，约束属性作用域的办法： using the `local` modifier)</span><br><span class="line">-- attribute [local simp] reverse_mk_symm -- 局部属性，outside the section, the simplifier will no longer use this theorem by default</span><br><span class="line"></span><br><span class="line">example (xs ys : List Nat) (p : List Nat → Prop)</span><br><span class="line">        (h : p (xs ++ mk_symm ys).reverse)</span><br><span class="line">        : p (mk_symm ys ++ xs.reverse) := by</span><br><span class="line">  simp at h; assumption</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/-“wildcard 通配符” *：</span><br><span class="line"> 代表所有的hypotheses and the goal</span><br><span class="line"> e.g. simp [*]</span><br><span class="line"> -/</span><br></pre></td></tr></table></figure>
<h2 id="Split-Tactic"><a href="#Split-Tactic" class="headerlink" title="Split Tactic"></a>Split Tactic</h2><p>The <code>split</code> tactic is useful for breaking nested if-then-else and match expressions in cases. For a match expression with n cases, the <code>split</code> tactic generates at most n subgoals.<br>拆分多种subgoal和match差不多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/-`simp_arith`:</span><br><span class="line"> is shorthand for simp with arith := true and decide := true. This enables the use of normalization by linear arithmetic.</span><br><span class="line">-/</span><br><span class="line">section</span><br><span class="line">def f (x y z: Nat): Nat :=</span><br><span class="line">  match x , y ,z with</span><br><span class="line">  | 0, _, _ =&gt; y</span><br><span class="line">  | _, 0, _ =&gt; z</span><br><span class="line">  | _, _, 0 =&gt; x</span><br><span class="line">  | _, _, _ =&gt; 1</span><br><span class="line">example (x y z : Nat) : x ≠ 0 → y ≠ 0 → z ≠ 0 → z = w → f x y w = 1 := by</span><br><span class="line">  intros -- f x y w = 1</span><br><span class="line">  simp [f]    /-(match x, y, w with</span><br><span class="line">              | 0, x, x_1 =&gt; y</span><br><span class="line">              | x, 0, x_1 =&gt; w</span><br><span class="line">              | x_1, x_2, 0 =&gt; x</span><br><span class="line">              | x, x_1, x_2 =&gt; 1) =</span><br><span class="line">              1-/</span><br><span class="line">  split ;repeat (first | contradiction| rfl)</span><br><span class="line"></span><br><span class="line">  -- split &lt;;&gt; first | contradiction | rfl</span><br><span class="line"></span><br><span class="line">  -- split</span><br><span class="line">  -- case h_1 =&gt; contradiction</span><br><span class="line">  -- case h_2 =&gt; contradiction</span><br><span class="line">  -- case h_3 =&gt; contradiction</span><br><span class="line">  -- case h_4 =&gt; rfl</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>by default, <code>simp</code> include all theorems that have been marked with the attribute [simp].<br>Writing <code>simp only</code> excludes these defaults, allowing you to use a more explicitly crafted list of rules. In the examples below, the <code>minus sign</code> and <code>only</code> are used to block the application of reverse_mk_symm.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">example (xs ys : List Nat) (p : List Nat → Prop)</span><br><span class="line">        (h : p (xs ++ mk_symm ys).reverse)</span><br><span class="line">        : p ((mk_symm ys).reverse ++ xs.reverse) := by</span><br><span class="line">  simp [-reverse_mk_symm] at h; assumption -- -负号</span><br><span class="line"></span><br><span class="line">example (xs ys : List Nat) (p : List Nat → Prop)</span><br><span class="line">        (h : p (xs ++ mk_symm ys).reverse)</span><br><span class="line">        : p ((mk_symm ys).reverse ++ xs.reverse) := by</span><br><span class="line">  simp only [List.reverse_append] at h; assumption -- only的应用</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/-`simp` tactic 的useful configuration options:</span><br><span class="line">&#123;contextual := true, arith := true, decide := true, ...&#125;</span><br><span class="line">-/</span><br><span class="line">-- 用x= 0 化简  y + x = y ，用x ≠ 0 化简 x ≠ 0</span><br><span class="line">example : if x = 0 then y + x = y else x ≠ 0 := by</span><br><span class="line">  simp (config := &#123; contextual := true &#125;)</span><br><span class="line"></span><br><span class="line">example : 0 &lt; 1 + x ∧ x + y + 2 ≥ y + 1 := by</span><br><span class="line">  simp_arith -- is a shorthand for `simp (config := &#123;arith := true&#125;)`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Extensible-Tactics"><a href="#Extensible-Tactics" class="headerlink" title="Extensible Tactics"></a>Extensible Tactics</h2><p>command <code>syntax</code> to define new tactics<br>command <code>macro_rules</code> to specify what should be done when the new tactic is used.<br>You can provide different expansions, and the tactic interpreter will try all of them until one succeeds.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--define a new tactic `my_tac`</span><br><span class="line">syntax &quot;my_tac&quot; : tactic</span><br><span class="line">macro_rules</span><br><span class="line">  | `(tactic| my_tac)=&gt; `(tactic| assumption)</span><br><span class="line">example (h : p) : p := by</span><br><span class="line">  my_tac</span><br><span class="line"></span><br><span class="line">-- extend `my_tac`</span><br><span class="line">macro_rules</span><br><span class="line">  | `(tactic| my_tac) =&gt; `(tactic|  rfl)</span><br><span class="line"></span><br><span class="line">example (x : α ): x = x:=by my_tac</span><br><span class="line"></span><br><span class="line">-- extend `my_tac`</span><br><span class="line">macro_rules</span><br><span class="line">  | `(tactic | my_tac) =&gt; `(tactic| apply And.intro &lt;;&gt;my_tac )</span><br><span class="line">example (x : α) (h : p) : x = x ∧ p := by</span><br><span class="line">  my_tac</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anaccountalready.github.io/2025/01/02/Mathematics-in-Lean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Yu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HelloWorld">
      <meta itemprop="description" content="Come to Play">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | HelloWorld">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/02/Mathematics-in-Lean/" class="post-title-link" itemprop="url">Mathematics_in_Lean</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-02 11:17:11" itemprop="dateCreated datePublished" datetime="2025-01-02T11:17:11+08:00">2025-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 18:01:36" itemprop="dateModified" datetime="2025-01-24T18:01:36+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Lean/" itemprop="url" rel="index"><span itemprop="name">Lean</span></a>
        </span>
    </span>

  
    <span id="/2025/01/02/Mathematics-in-Lean/" class="post-meta-item leancloud_visitors" data-flag-title="Mathematics_in_Lean" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/01/02/Mathematics-in-Lean/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/01/02/Mathematics-in-Lean/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>469</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Mathematics in lean ：基于mathlib库，建造复杂表达式的方式：1.自己写，2.提供instruction 指导如何构建<br>Theorem Proving in Lean: 侧重底层逻辑框架和Lean的核心语法</p>
<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><h2 id="2-basic"><a href="#2-basic" class="headerlink" title="2 basic"></a>2 basic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- le_div_iff₀这个theorem，以及rm[]</span><br><span class="line">-- 使用方面linarith(线性计算)，和ring(交换)</span><br><span class="line">-- 以及证明时可以把用的定理直接提出来，theorem</span><br><span class="line">-- have h:引入假设，calc 分步计算，让过程更加清晰，因为写出了要证明的每一步的结果</span><br><span class="line">-- tatics： apply , repeat</span><br></pre></td></tr></table></figure>
<h2 id="3-1-Impication-and-the-Universal-Quantifier"><a href="#3-1-Impication-and-the-Universal-Quantifier" class="headerlink" title="3.1 Impication and the Universal Quantifier"></a>3.1 Impication and the Universal Quantifier</h2><p>In lean,in a sequence of implications there are implicit parentheses grouped to the right. </p>
<p>it is common in Lean to use curly brackets to make quantified variables implicit when they can be inferred from subsequent hypotheses.So we can just do lemma to the hypothese without mentioning the objects.即用{}括起来的在调用时不需要显示指出。</p>
<h2 id="5-2-Induction-and-Recursion"><a href="#5-2-Induction-and-Recursion" class="headerlink" title="5.2 Induction and Recursion"></a>5.2 Induction and Recursion</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 归纳</span><br><span class="line">-- inductive types (which are types generated infuctively by a given list of constructors)</span><br><span class="line">-- e.g. the natual numbers are declared as follows( in Prelude.lean)</span><br><span class="line">inductive Nat where</span><br><span class="line">  | zero : Nat -- constructor</span><br><span class="line">  | succ (n : Nat): Nat -- constructor</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">@[simp] -- specifys that the defining equation should be added to the database of identities that the simplifier uses by default</span><br></pre></td></tr></table></figure>

<h2 id="6-1-Defining-Structures"><a href="#6-1-Defining-Structures" class="headerlink" title="6.1 Defining Structures"></a>6.1 Defining Structures</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">structure structure_name where</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h3 id="annotation-when-define-a-structure："><a href="#annotation-when-define-a-structure：" class="headerlink" title="annotation when define a structure："></a>annotation when define a structure：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@[ext] -- extensionality,tells Lean to automatically generate theorems that can be used to prove that two instances of a structure are equal when their components are equal.</span><br></pre></td></tr></table></figure>
<h3 id="define-particular-instances-of-structure"><a href="#define-particular-instances-of-structure" class="headerlink" title="define particular instances of structure"></a>define particular instances of structure</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def inst_name : struc_name where</span><br><span class="line">  ...</span><br><span class="line">  -- e.g. x:=1</span><br><span class="line">---------------------------------</span><br><span class="line">def inst_name : struct_name :=</span><br><span class="line">  ...</span><br><span class="line">  --e.g. &lt;value1 , ,...&gt; -- anonymous constructor notation</span><br><span class="line">---------------------------------</span><br><span class="line">def inst_name :=</span><br><span class="line">  struc_name.mk ...valuek valuek+1 ...</span><br><span class="line">  -- struc_name.mk 是constructor，也可以自己命名，需要在define structure 的时候，比where多 了name和::</span><br><span class="line">  -- structure struc_name where constructor_name ::</span><br><span class="line">  --    ...</span><br><span class="line">-- open a namespace</span><br><span class="line">namespace namespace_name</span><br><span class="line">...</span><br><span class="line">end namespace_name</span><br></pre></td></tr></table></figure>
<h3 id="definations-and-theorems"><a href="#definations-and-theorems" class="headerlink" title="definations and theorems"></a>definations and theorems</h3><p>about namespace: when namespace not open, can use anonymous projection notation,which allows us to write <strong>a.add b</strong> instead of <strong>namespace_name.add a b</strong>.</p>
<p><strong>protected</strong> keyword</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- so that the theorem name is Point.add_comm,even when the namespace is open</span><br><span class="line">protected theorem add_comm (a b :Point) :add a b = add b a:=by</span><br><span class="line">  sorry</span><br></pre></td></tr></table></figure>
<h1 id="Lean-theorem"><a href="#Lean-theorem" class="headerlink" title="Lean theorem"></a>Lean theorem</h1><p>multiple arrows：隐式右结合（associate to the right）</p>
<h1 id="Lean使用快捷键"><a href="#Lean使用快捷键" class="headerlink" title="Lean使用快捷键"></a>Lean使用快捷键</h1><p>Ctrl-Shift-P ： get access to the Lean 4:show all abbreviations<br>Ctrl-Space : completion in the editior to guess the theorem name</p>
<h1 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h1><h2 id="运算的特殊写法"><a href="#运算的特殊写法" class="headerlink" title="运算的特殊写法"></a>运算的特殊写法</h2><ol>
<li>divisibility relation整除关系 |</li>
</ol>
<h2 id="提示写法"><a href="#提示写法" class="headerlink" title="提示写法"></a>提示写法</h2><p>“apply?”可以在右边得到suggestions</p>
<h2 id="重复证明过程的写法"><a href="#重复证明过程的写法" class="headerlink" title="重复证明过程的写法"></a>重复证明过程的写法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--1. 使用hypothesis ：任意</span><br><span class="line">--2. 使用repeat</span><br><span class="line">example : min a b = min b a := by</span><br><span class="line">  have h : ∀ x y : ℝ, min x y ≤ min y x := by</span><br><span class="line">    intro x y</span><br><span class="line">    apply le_min</span><br><span class="line">    apply min_le_right</span><br><span class="line">    apply min_le_left</span><br><span class="line">  apply le_antisymm</span><br><span class="line">  apply h</span><br><span class="line">  apply h</span><br><span class="line">-----------------------</span><br><span class="line">example : min a b = min b a := by</span><br><span class="line">  apply le_antisymm</span><br><span class="line">  repeat</span><br><span class="line">    apply le_min</span><br><span class="line">    apply min_le_right</span><br><span class="line">    apply min_le_left</span><br></pre></td></tr></table></figure>
<h2 id="name-of-theorem"><a href="#name-of-theorem" class="headerlink" title="name_of_theorem"></a>name_of_theorem</h2><p>A_of_B_of_C: established something of the form A from hypothese of the form B and C,where A,B,C approximate the way we might read the goals out loud,e.g. x+y&lt;… probably start with add_lt.</p>
<h2 id="example-use-by-not-use-by"><a href="#example-use-by-not-use-by" class="headerlink" title="example use by &amp; not use by"></a>example use by &amp; not use by</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example (a b : R) : a - b = a + -b :=by</span><br><span class="line">  rw[sub_eq_add_neg a b]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">example (a b : R) : a - b = a + -b :=</span><br><span class="line">  sub_eq_add_neg a b</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="语法记录"><a href="#语法记录" class="headerlink" title="语法记录"></a>语法记录</h1><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--</span><br><span class="line">section ... end</span><br><span class="line">-- 变量声明</span><br><span class="line">variable(v1 v2 v3 ... : type) </span><br><span class="line">-- 检查类型，或描述用法</span><br><span class="line">#check ...</span><br><span class="line">#check a -- a:R</span><br><span class="line">#check mul_comm -- mul_comm.&#123;u_1&#125; &#123;G : Type u_1&#125; [CommMagma G] (a b : G) : a * b = b * a</span><br><span class="line"></span><br><span class="line">#check norm_num -- 常量计算与比较，Normalize numerical expressions. Supports the operations + - * / ⁻¹ ^ and % over numerical types such as ℕ, ℤ, ℚ, ℝ, ℂ and some general algebraic types, and can prove goals of the form A = B, A ≠ B, A &lt; B and A ≤ B, where A and B are numerical expressions. It also has a relatively simple primality prover.</span><br><span class="line"></span><br><span class="line">-- Nat.gcd m n :最大公约数,在显示的时候会显示出来m.gcd.n</span><br></pre></td></tr></table></figure>

<h3 id="rfl-is-short-for-“reflexivity”"><a href="#rfl-is-short-for-“reflexivity”" class="headerlink" title="rfl is short for “reflexivity”."></a>rfl is short for “reflexivity”.</h3><h3 id="calc先定义阶段目标再填写过程"><a href="#calc先定义阶段目标再填写过程" class="headerlink" title="calc先定义阶段目标再填写过程"></a>calc先定义阶段目标再填写过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">example:(a+b)*(a+b) = a*a+2*a*b +b*b:</span><br><span class="line">    calc</span><br><span class="line">        xx :by</span><br><span class="line">            xx</span><br><span class="line">        _=xxx:=by</span><br><span class="line">            xx</span><br><span class="line">        _=xxxx:=by</span><br><span class="line">            xxxx</span><br></pre></td></tr></table></figure>
<h3 id="have-先提出假设h进行证明，之后可以使用h推断goal"><a href="#have-先提出假设h进行证明，之后可以使用h推断goal" class="headerlink" title="have 先提出假设h进行证明，之后可以使用h推断goal"></a>have 先提出假设h进行证明，之后可以使用h推断goal</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">theorem zero_mul(a: R):0*a  =0 := by</span><br><span class="line">    have h: 0*a+0*a = 0*a+0 :=by</span><br><span class="line">        rw[←add_mul,add_zero,add_zero]</span><br><span class="line">    rw[add_left_cancel h]</span><br></pre></td></tr></table></figure>
<h3 id="rw-…-…-…-替换"><a href="#rw-…-…-…-替换" class="headerlink" title="rw[…,…,…]替换"></a>rw[…,…,…]替换</h3><ol>
<li>变量</li>
</ol>
<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>左箭头表示a&#x3D;b:用a替换b</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nth_rw &lt;第几个&gt;[]替换</span><br><span class="line">rw[mul_assoc]--a*b*c = a*(b*c)</span><br><span class="line">rw[mul_assoc]--a*(b*c)=a*b*c</span><br><span class="line">sub_self -- a-a=0</span><br></pre></td></tr></table></figure>
<p>&lt;⬅&gt;mul_assoc <v><br>mul_comm &lt;v1,v2&gt;</p>
<h3 id="tactic：ring"><a href="#tactic：ring" class="headerlink" title="tactic：ring"></a>tactic：ring</h3><p>automation for that follow purely from the ring axioms</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">example: c*b*a = b*(a*c):= by</span><br><span class="line">    ring</span><br></pre></td></tr></table></figure>
<p>a ring consists of a collection of<br>objects,<br>R,(R with + is an <strong>abelian group</strong>,with 0 as the additive identity , with negation as inverse)<br>operations + *,and (multiplication is associative with identity 1,and multiplication distributes over addition)<br>constants 0 and 1,and<br>an operation x-&gt;-x </p>
<p>Lean is good not only for proving things about concrete mathematical structures like the natural numbers and the integers, but also for proving things about abstract structures, characterized axiomatically, like rings. Moreover, Lean supports generic reasoning about both abstract and concrete structures, and can be trained to recognize appropriate instances.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anaccountalready.github.io/2024/12/31/Lean4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Yu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HelloWorld">
      <meta itemprop="description" content="Come to Play">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | HelloWorld">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/31/Lean4/" class="post-title-link" itemprop="url">Lean4</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-31 16:15:29" itemprop="dateCreated datePublished" datetime="2024-12-31T16:15:29+08:00">2024-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-02 00:18:13" itemprop="dateModified" datetime="2025-01-02T00:18:13+08:00">2025-01-02</time>
    </span>

  
    <span id="/2024/12/31/Lean4/" class="post-meta-item leancloud_visitors" data-flag-title="Lean4" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/12/31/Lean4/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/12/31/Lean4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>227</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Lean4：被称为交互式定理证明器（interactive theorem-proving system）的计算机系统（也称为证明助手或形式化系统）提供了另一种表达数学论证的方法。<br>mathlib(Lean mathematical library)是一项由社区推动的工作，旨在建立一个以lean proof assistant形式化的统一数学库。<br>a proof assistant：(一个软件，提供规范语言，依照规范语言定义对象和性质，证明定理，系统检查定理的正确性，直至逻辑基础)<br>Formalization:  我们将用一种规范的语言（如编程语言）来书写数学定义、定理和证明，让 Lean 能够理解。 作为回报，Lean 会提供反馈和信息，解释表达式并保证其格式正确，并最终认证我们证明的正确性。</p>
<p>Lean 是一个工具将复杂表达式转换成形式化语言(dependent type theory)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anaccountalready.github.io/2024/12/11/BugBlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Yu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HelloWorld">
      <meta itemprop="description" content="Come to Play">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | HelloWorld">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/11/BugBlog/" class="post-title-link" itemprop="url">BugBlog</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-11 17:01:51" itemprop="dateCreated datePublished" datetime="2024-12-11T17:01:51+08:00">2024-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-25 23:57:52" itemprop="dateModified" datetime="2024-12-25T23:57:52+08:00">2024-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
        </span>
    </span>

  
    <span id="/2024/12/11/BugBlog/" class="post-meta-item leancloud_visitors" data-flag-title="BugBlog" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/12/11/BugBlog/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/12/11/BugBlog/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JAVA</span></span><br><span class="line"><span class="comment">// Wrong!!!,这样写改不了树，put不进去</span></span><br><span class="line"><span class="comment">//	public void NonrecursivePut(Key key,Value val)&#123;</span></span><br><span class="line"><span class="comment">//		if(key==null)throw new IllegalArgumentException(&quot;the 1st of Put() is null&quot;);</span></span><br><span class="line"><span class="comment">//		Node x = root;</span></span><br><span class="line"><span class="comment">//		while(x!=null)&#123;</span></span><br><span class="line"><span class="comment">//			int cmp = key.compareTo(x.key);</span></span><br><span class="line"><span class="comment">//			if(cmp&gt;0) x=x.right;</span></span><br><span class="line"><span class="comment">//			else if(cmp&lt;0) x= x.left;</span></span><br><span class="line"><span class="comment">//			else x.val=val;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		x=new Node(key,val);Wrong!!因为只是将临时引用指向了新创建的对象，而实际的x.left或x.right引用依然为null</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution: 记录父节点，通过修改父节点.left和right进行</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anaccountalready.github.io/2024/10/26/compiler-impletment-learn-from-Jack-W-Crenshaw/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Yu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HelloWorld">
      <meta itemprop="description" content="Come to Play">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | HelloWorld">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/26/compiler-impletment-learn-from-Jack-W-Crenshaw/" class="post-title-link" itemprop="url">compiler impletment learn from Jack W. Crenshaw</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-26 23:18:51" itemprop="dateCreated datePublished" datetime="2024-10-26T23:18:51+08:00">2024-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 10:34:51" itemprop="dateModified" datetime="2024-11-21T10:34:51+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
        </span>
    </span>

  
    <span id="/2024/10/26/compiler-impletment-learn-from-Jack-W-Crenshaw/" class="post-meta-item leancloud_visitors" data-flag-title="compiler impletment learn from Jack W. Crenshaw" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/10/26/compiler-impletment-learn-from-Jack-W-Crenshaw/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/10/26/compiler-impletment-learn-from-Jack-W-Crenshaw/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>469</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://compilers.iecc.com/crenshaw">学习网站</a></p>
<h1 id="学习过程中的不懂问题"><a href="#学习过程中的不懂问题" class="headerlink" title="学习过程中的不懂问题"></a>学习过程中的不懂问题</h1><blockquote>
<p>使用栈计算表达式时，‘)’ had  different precedence levels,depending upon whether or not it was already on the stack,you had to give it one value before you put it on the stack, and another to decide when to take it off.(不明白为啥右括号有不同优先级，咋还能入栈)<br>difference between interpreter and compiler : the recognizing of procedure, in the interpreter the recognizing procedure end up being coded as FUNCTIONS that return numeric values to their callers.None of the parsing routines for our compiler did that（不明白解释器和编译器在procedure翻译上的不同）<br>assembler: 目的是生成object code,normally does that on a one-to-one basis(one object instruction per line of source code),but almost ebery assember also permits expression as arguments.In this case, the expression are always constant expressions, and so the assembler isn’t supposed to issue object code for them. Rather, it “interpreters” the expression and computes the corresponding constant result,which is what it actually emits as object code（此处说的汇编器对常量表达式的处理是“lazy”概念，exap: x &#x3D; x+3-2-1最后生成时是对 x&#x3D; x+0甚至是x&#x3D;x）</p>
</blockquote>
<h1 id="阶段1-Single-Num-expression"><a href="#阶段1-Single-Num-expression" class="headerlink" title="阶段1 Single Num expression"></a>阶段1 Single Num expression</h1><h2 id="只含”-“的二元表达式"><a href="#只含”-“的二元表达式" class="headerlink" title="只含”+-“的二元表达式"></a>只含”+-“的二元表达式</h2><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    expr::= term&lt;+-term&gt;</span></span><br><span class="line"><span class="comment">    term::=GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Expression</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term;<span class="comment">&#123;MOVE #GetNum,D0;&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;MOVE D0,D1&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: Add;<span class="comment">&#123;Match(&#x27;+&#x27;);Term;ADD D1,D0;结果存在D0&#125;</span></span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: Substract;<span class="comment">&#123;Match(&#x27;-&#x27;);Term;SUB D1,D0;NEG D0;结果存在D0&#125;</span></span><br><span class="line">    <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="多个操作数"><a href="#多个操作数" class="headerlink" title="多个操作数"></a>多个操作数</h2><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;循环解决,将数压栈解决寄存器有限&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Expression</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term;<span class="comment">&#123;MOVE #GetNum,D0;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>);<span class="comment">&#123;D1=D0;&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: Add;<span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract;<span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB -(SP),D0; NEG D0 ;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="增加”-“"><a href="#增加”-“" class="headerlink" title="增加”*&#x2F;“"></a>增加”*&#x2F;“</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    优先级高，单位更小</span></span><br><span class="line"><span class="comment">    expr::= term &lt;+- term&gt;</span></span><br><span class="line"><span class="comment">    term::= factor &lt;*/ factor&gt;</span></span><br><span class="line"><span class="comment">    factor::= GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Expression</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Term<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;压栈&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="keyword">Add</span><span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB (SP)-,D0; NEG D0;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Term</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Factor<span class="punctuation">;</span><span class="comment">&#123;GetNum;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: Multiply<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;*&#x27;);Factor;MUL (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: Divide<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;乘除操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<h2 id="增加”-”"><a href="#增加”-”" class="headerlink" title="增加”()”"></a>增加”()”</h2><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">    factor ::= (expr) or GetNum</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Factor</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look =<span class="string">&#x27;(&#x27;</span> than <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE&#x27;</span>+#GetNum+<span class="string">&#x27;,D0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="增加”-作为正负号的数”"><a href="#增加”-作为正负号的数”" class="headerlink" title="增加”-+作为正负号的数”"></a>增加”-+作为正负号的数”</h2><p>增加0-</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    expr::=- or term&lt;+-term&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;------------------------------------------------------------&#125;</span></span><br><span class="line"><span class="keyword">procedure</span> <span class="title function_">Expression</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;CLR D0&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;D0=0;&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        term<span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">while</span> Look <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        EmitLn(<span class="string">&#x27;MOVE D0,-(SP)&#x27;</span>)<span class="punctuation">;</span><span class="comment">&#123;压栈&#125;</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="keyword">Add</span><span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;+&#x27;);Term; ADD (SP)+,D0;&#125;</span></span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: Substract<span class="punctuation">;</span><span class="comment">&#123;Match(&#x27;-&#x27;);Term; SUB (SP)-,D0; NEG D0;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> Expected(<span class="string">&#x27;加减操作符&#x27;</span>)<span class="punctuation">;</span></span><br><span class="line">        <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line">    <span class="keyword">end</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">end</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>


<h1 id="阶段2-Assignment（name-expression，多位数和标识符Token识别）"><a href="#阶段2-Assignment（name-expression，多位数和标识符Token识别）" class="headerlink" title="阶段2 Assignment（name &#x3D; expression，多位数和标识符Token识别）"></a>阶段2 Assignment（name &#x3D; expression，多位数和标识符Token识别）</h1><h2 id="增加-单个字母的标识符（以及无参的函数调用C语言格式）"><a href="#增加-单个字母的标识符（以及无参的函数调用C语言格式）" class="headerlink" title="增加 单个字母的标识符（以及无参的函数调用C语言格式）"></a>增加 单个字母的标识符（以及无参的函数调用C语言格式）</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    factor ::= GetNum | (expre) | Ident</span></span><br><span class="line"><span class="comment">    Ident ::= GetName &lt;&#x27;(&#x27;&#x27;)&#x27;&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;-------------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Factor</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> Look =<span class="string">&#x27;(&#x27;</span> than <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> IsAlpha(Look) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        Ident;<span class="comment">&#123;标识符识别&#125;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       EmitLn(<span class="string">&#x27;MOVE&#x27;</span>+#GetNum+<span class="string">&#x27;,D0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;----------------------------------------&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Ident</span>;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">Name</span>:Char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">Name</span> :=GetName;</span><br><span class="line">    <span class="keyword">if</span> Look = <span class="string">&#x27;(&#x27;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        Match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        EmitLn(<span class="string">&#x27;BSR &#x27;</span>+<span class="keyword">Name</span>);<span class="comment">&#123;调用函数&#125;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> EmitLn(<span class="string">&#x27;MOVE &#x27;</span>+<span class="keyword">Name</span>+<span class="string">&#x27;(PC),D0&#x27;</span>);<span class="comment">&#123;将操作数取出来放在D0&#125;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="增加赋值语句"><a href="#增加赋值语句" class="headerlink" title="增加赋值语句"></a>增加赋值语句</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Assignment ::= GetName = expr</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Assignment</span>;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">Name</span>:char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">Name</span>:=GetName;</span><br><span class="line">    Match(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    Expression;</span><br><span class="line">    <span class="comment">&#123;赋值汇编&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;LEA &#x27;</span>+<span class="keyword">Name</span>+<span class="string">&#x27;(PC)&#x27;</span>,A0);<span class="comment">&#123;A0是地址寄存器，存放Name的地址，PC相对寻址&#125;</span></span><br><span class="line">    EmitLn(<span class="string">&#x27;MOVE D0,(A0)&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="增加多位数和多个字母"><a href="#增加多位数和多个字母" class="headerlink" title="增加多位数和多个字母"></a>增加多位数和多个字母</h2><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    GetNum，GetName重写<span class="keyword">while</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> GetNum:<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">var</span> Value:<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Value:=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isDigit(Look) <span class="keyword">then</span> Expected(<span class="string">&#x27;Digit&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> isDigit(Look) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        Value:=Value+Look;</span><br><span class="line">        GetChar;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="增加空格过滤"><a href="#增加空格过滤" class="headerlink" title="增加空格过滤"></a>增加空格过滤</h2><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    识别空格，过滤空格，保证其余的识别开头第一个是非空格字符，即：</span><br><span class="line"></span><br><span class="line">    Init 中GetChar后要SkipWhite；</span><br><span class="line"></span><br><span class="line">    GetNum/Name 最后要SkipWhite;</span><br><span class="line">    </span><br><span class="line">    tips: LR (<span class="name">#10</span>,<span class="comment">^J</span>) CR($<span class="number">13</span>,<span class="comment">^M</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="阶段3：简单的interpreter"><a href="#阶段3：简单的interpreter" class="headerlink" title="阶段3：简单的interpreter"></a>阶段3：简单的interpreter</h1><p>interpreter就是等到必要时才打印，否则就一直计算</p>
<h2 id="识别表达式"><a href="#识别表达式" class="headerlink" title="识别表达式"></a>识别表达式</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr := -<span class="comment">/+ term &lt;+/</span>- term&gt;</span><br><span class="line">term := factor &lt;*/ factor&gt;</span><br><span class="line">factor := GetNum | (expr) </span><br></pre></td></tr></table></figure>
<h3 id="一位数字-即时计算"><a href="#一位数字-即时计算" class="headerlink" title="一位数字(即时计算)"></a>一位数字(即时计算)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">-------------------------&#125;</span></span><br><span class="line">&#123;GetNum&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">GetNum:integer;</span></span><br><span class="line">begin</span><br><span class="line">    if not <span class="keyword">is</span>Digit(Look) <span class="keyword">then</span> Expected(<span class="symbol">&#x27;Integer</span>&#x27;);</span><br><span class="line">    GetNum := Ord(Look)-Ord(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    GetChar;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">----------------------------&#125;</span></span><br><span class="line">&#123;Factor&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Factor:integer;</span></span><br><span class="line">begin</span><br><span class="line">    if Look = &#x27;(&#x27; then</span><br><span class="line">    begin</span><br><span class="line">        Match(&#x27;(&#x27;);</span><br><span class="line">        Factor := Expression;</span><br><span class="line">        Match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> Factor := GetNum;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">-------------------------------&#125;</span></span><br><span class="line">&#123; Term &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Term:integer;</span></span><br><span class="line">var</span><br><span class="line">    Value :integer;</span><br><span class="line">begin</span><br><span class="line">    Value := Factor;</span><br><span class="line">    while <span class="keyword">is</span>Mulop(Look) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            Value:=Value * Factor;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            Value:=Value div Factor;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    Term := Value;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">-----------------------------&#125;</span></span><br><span class="line">&#123;Expression&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">Expression:integer;</span></span><br><span class="line">var</span><br><span class="line">    Value:integer;</span><br><span class="line">begin</span><br><span class="line">    if <span class="keyword">is</span>Addop(Look) <span class="keyword">then</span> <span class="keyword">begin</span>&#123;能省略吗？不能因为省略后无法识别Term开头的表达式&#125;</span><br><span class="line">        Value:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> Value:= Term;</span><br><span class="line">    <span class="keyword">while</span> isAddop(Look) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span></span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            Value := Value +Term;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Match(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            Value := Value -Term;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    Expression := Value;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="多位数字-改动GetNum"><a href="#多位数字-改动GetNum" class="headerlink" title="多位数字(改动GetNum)"></a>多位数字(改动GetNum)</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">procadure GetChar;</span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">    <span class="title">Read</span><span class="params">(Look)</span></span>;</span><br><span class="line">end;</span><br><span class="line">function GetNum:integer;</span><br><span class="line">var</span><br><span class="line">    Value: integer;</span><br><span class="line">begin</span><br><span class="line">    Value :=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="keyword">not</span> <span class="title">isDigit</span><span class="params">(Look)</span> then <span class="title">Expected</span><span class="params">(<span class="string">&quot;Integer&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">isDigit</span><span class="params">(Look)</span> <span class="keyword">do</span></span></span><br><span class="line"><span class="function">    begin</span></span><br><span class="line"><span class="function">        Value :=</span> Value * <span class="number">10</span> +<span class="built_in">Ord</span>(Look)-<span class="built_in">Ord</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        GetChar;</span><br><span class="line">    end;</span><br><span class="line">    GetNum := Value;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h3 id="NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出"><a href="#NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出" class="headerlink" title="NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出"></a>NewLine，，WhiteSpace；循环解释，结束符与单字母符号表的初始化和输出</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    在我的电脑上windows的WSL上NewLine只用了LF</span></span><br><span class="line"><span class="comment">    结束符.</span></span><br><span class="line"><span class="comment">    输入符号表命令 ？Name Value</span></span><br><span class="line"><span class="comment">    输出符号表命令 ！Name </span></span><br><span class="line"><span class="comment">    对于WhiteSpace（在一个单元结束下一个单元开始前跳过中间的空格）：最小读取单元是数字或者单个字符，故在init的GetChar后添加skipWhite，在GetNum和GetName结束添加skipWhite（读到第一个非空格字符）,还需要在match后加上skipWhite</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123; 符号表 &#125;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">Table[<span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>] <span class="keyword">of</span> integer;</span><br><span class="line"><span class="comment">&#123; Input Table&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Input</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Match(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    <span class="keyword">Read</span>(Table[GetName]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">&#123;Output&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Output</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    Match(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="keyword">Write</span>(Table[GetName]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">NewLine</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> isNewLine(Look) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            GetChar;</span><br><span class="line">            SkipWhite;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">&#123; Main &#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">case</span> Look <span class="keyword">of</span> </span><br><span class="line">        <span class="string">&#x27;?&#x27;</span>: Input;</span><br><span class="line">        <span class="string">&#x27;!&#x27;</span>: Output;</span><br><span class="line">        <span class="keyword">else</span> Assignment;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        NewLine;</span><br><span class="line">        <span class="keyword">until</span> Look = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anaccountalready.github.io/2024/10/05/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Yu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HelloWorld">
      <meta itemprop="description" content="Come to Play">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | HelloWorld">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/05/hello-world/" class="post-title-link" itemprop="url">Next主题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-05 22:53:24" itemprop="dateCreated datePublished" datetime="2024-10-05T22:53:24+08:00">2024-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-07 23:59:50" itemprop="dateModified" datetime="2024-10-07T23:59:50+08:00">2024-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hexo-Next/" itemprop="url" rel="index"><span itemprop="name">Hexo-Next</span></a>
        </span>
    </span>

  
    <span id="/2024/10/05/hello-world/" class="post-meta-item leancloud_visitors" data-flag-title="Next主题" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/10/05/hello-world/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/10/05/hello-world/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="指路Next入门教程"><a href="#指路Next入门教程" class="headerlink" title="指路Next入门教程"></a><a target="_blank" rel="noopener" href="https://hexo-next.readthedocs.io/zh-cn/latest/next/">指路Next入门教程</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">3k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11 分钟</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/anaccountalready" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"A5zlbd7Eq59WTRm9PFZjwTlZ-MdYXbMMI","app_key":"WB7CRWUP9pq5C7owLEv1VD0A","server_url":"https://api.anaccountalready.cn","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://www.anaccountalready.cn","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"locale":{"placeholder":"Welcome to comment"},"placeholder":null,"avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":false,"requiredFields":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
